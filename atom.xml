<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CDBlog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-27T10:33:37.980Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>chendong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>cfca的一个加密失败的问题</title>
    <link href="http://yoursite.com/2019/10/07/cfca%E7%9A%84%E4%B8%80%E4%B8%AA%E5%8A%A0%E5%AF%86%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/10/07/cfca的一个加密失败的问题/</id>
    <published>2019-10-07T12:22:20.000Z</published>
    <updated>2019-10-27T10:33:37.980Z</updated>
    
    <content type="html"><![CDATA[<p>在金融领域，cfca(中国金融认证中心)是必然会接触的，使用了cfca键盘，提供了客户端到服务端的加解密功能。</p><p>在某个需求时遇到一个cfca加解密失败。</p><p>功能伪代码如下, 先接口获取开关配置，再决定展示UI。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;div v-if=&quot;enable&quot;&gt;</span><br><span class="line">        // other code</span><br><span class="line">        // ...</span><br><span class="line">        &lt;cfca /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div v-else&gt;</span><br><span class="line">        // ...</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;enable:false&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    async created() &#123;</span><br><span class="line">        const enable = await getConfig(&apos;enable&apos;);</span><br><span class="line">        this.enable = enable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>提交请求后，提示解密失败。</p><ol><li><p>回顾下这个功能，就加解密功能而言，cfca是第三方服务，而且其他页面使用中没问题，所以原因不在cfca。<br>而加解密功能，都是cfca提供的，客户端按照流程提供密文和密钥即可。</p></li><li><p>解密失败，则说明提供的密钥和进行加密的密钥不一致。</p></li><li><p>如果，使用者密钥存储在服务端，那跟前端无关，就不会在这个功能点报错。<br>所以，推测密钥存储在客户端。</p></li><li><p>cfca提供的是一个iife的sdk，并进行了组件级的封装。 完成了键盘组件的初始化，交互与加密传输。</p></li><li><p>加密方式对不上，那么加密初始化存在问题。js存储方式无非几种。1. 内存中，如挂载在全局的window下面； 2. 缓存，localStorage sessionStorage  3. 页面DOM中的data tag</p></li><li><p>如果是跟页面无关的存储，如window storage, 那么密钥应该是一致的，不存在变更。 所以，加密方式与密钥很可能是存储到DOM中。 查看组件的初始化操作，发现，组件进行了初始化请求密钥和随机数之后，<br>初始化了键盘，在之后的键盘操作中，会对键盘点击的数据进行加密，会得到加密的数据结果。</p></li><li><p>而 v-if 指令值为false时，是不会渲染DOM的，那么初始化键盘将找不到目标，失败。当v-if为true，渲染出键盘时，内部加密的随机数已经不存在了。</p></li></ol><p>所以，我们将v-if 替换为 v-show， 保证键盘组件一直存在，解决了问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在金融领域，cfca(中国金融认证中心)是必然会接触的，使用了cfca键盘，提供了客户端到服务端的加解密功能。&lt;/p&gt;
&lt;p&gt;在某个需求时遇到一个cfca加解密失败。&lt;/p&gt;
&lt;p&gt;功能伪代码如下, 先接口获取开关配置，再决定展示UI。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>移动端iOS部分兼容</title>
    <link href="http://yoursite.com/2019/10/07/%E7%A7%BB%E5%8A%A8%E7%AB%AFiOS%E9%83%A8%E5%88%86%E5%85%BC%E5%AE%B9/"/>
    <id>http://yoursite.com/2019/10/07/移动端iOS部分兼容/</id>
    <published>2019-10-07T12:21:51.000Z</published>
    <updated>2019-10-27T10:33:45.059Z</updated>
    
    <content type="html"><![CDATA[<ol><li>iOS引入图片资源时，在https下因为安全机制，不能渲染http的图片</li><li>img标签的onload事件无法在iOS中识别，但js的onload则可以。 <img src="http://src..." onload=""> 替换为 {const img = new Image(); img.onload=function(e){}; img.src=”<a href="http://src...&quot;}" target="_blank" rel="noopener">http://src...&quot;}</a>;</li><li>iOS下的input光标层级较高，会在弹出的mask层上展示，需要在 input 的父元素增加<code>postion:relative</code></li><li>input输入时，iOS键盘弹起，关闭键盘后，页面内容不自动回弹。iOS下还存在 <code>focusin</code> <code>focusout</code> 表单两个事件，监听focusout时，页面进行dom回弹即可。</li><li>iOS不像安卓一样，存在开放的文件夹入口，只提供了图片/视频的入口。 当iOS下载文件时，比如word pdf，需要先用APP授权并打开，之后在APP中进行访问。APP间类似独立沙盒，数据不能直接互通。<br>所以，涉及文件下载的功能点时，需要考虑这点。比如，提供预览，和复制url，引导用户外部下载。</li></ol><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;iOS引入图片资源时，在https下因为安全机制，不能渲染http的图片&lt;/li&gt;
&lt;li&gt;img标签的onload事件无法在iOS中识别，但js的onload则可以。 &lt;img src=&quot;http://src...&quot; onload=&quot;&quot;&gt; 替换为 {const img = new Image(); img.onload=function(e){}; img.src=”&lt;a href=&quot;http://src...&amp;quot;}&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://src...&amp;quot;}&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;iOS下的input光标层级较高，会在弹出的mask层上展示，需要在 input 的父元素增加&lt;code&gt;postion:relative&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;input输入时，iOS键盘弹起，关闭键盘后，页面内容不自动回弹。iOS下还存在 &lt;code&gt;focusin&lt;/code&gt; &lt;code&gt;focusout&lt;/code&gt; 表单两个事件，监听focusout时，页面进行dom回弹即可。&lt;/li&gt;
&lt;li&gt;iOS不像安卓一样，存在开放的文件夹入口，只提供了图片/视频的入口。 当iOS下载文件时，比如word pdf，需要先用APP授权并打开，之后在APP中进行访问。APP间类似独立沙盒，数据不能直接互通。&lt;br&gt;所以，涉及文件下载的功能点时，需要考虑这点。比如，提供预览，和复制url，引导用户外部下载。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>css实现文字镂空</title>
    <link href="http://yoursite.com/2019/10/07/css%E5%AE%9E%E7%8E%B0%E6%96%87%E5%AD%97%E9%95%82%E7%A9%BA/"/>
    <id>http://yoursite.com/2019/10/07/css实现文字镂空/</id>
    <published>2019-10-07T11:11:24.000Z</published>
    <updated>2019-10-07T12:21:17.261Z</updated>
    
    <content type="html"><![CDATA[<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>场景需求是对于动态的几个字符，从左到右，对文字进行染色。</p><ol><li>动画，从左到右</li><li>文字需要染色，可纯色或者渐变色</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>文字染色，能控制的是 color 属性， 但 color 无法动画过渡</li><li>能过渡的属性，一般用背景色</li><li>背景色的话，会把整个背景染色，无法单独染色文字而不影响默认背景色</li></ol><p>需要的一个属性，能染色文字而不影响背景色<br><code>-webkit-background-clip: text;</code></p><p>那么，如果不用这个属性，怎么实现呢 ？</p><p>思路：</p><ol><li><p>用图片替代文字<br>需要满足条件： 字符数量可控<br>同时，没有染色的过渡效果，可以考虑降级用透明度过渡</p></li><li><p>用绝对定位的小块拼凑字符，然后根据时间，加上class进行过渡<br>同样，需要满足字符数量可控。<br>实现上，可控的字符需要绝对定位就行拼凑，切换class进行过渡，每个字符需要单独进行顺序控制，实现繁琐。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h3&gt;&lt;p&gt;场景需求是对于动态的几个字符，从左到右，对文字进行染色。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;动画，从左到右&lt;/li&gt;
&lt;li&gt;文字需要染色，可纯色或
      
    
    </summary>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>改变上下文bind apply call</title>
    <link href="http://yoursite.com/2019/05/04/%E6%94%B9%E5%8F%98%E4%B8%8A%E4%B8%8B%E6%96%87bind-apply-call/"/>
    <id>http://yoursite.com/2019/05/04/改变上下文bind-apply-call/</id>
    <published>2019-05-04T08:10:43.000Z</published>
    <updated>2019-05-04T08:15:09.438Z</updated>
    
    <content type="html"><![CDATA[<p>bind 返回一个函数， call apply 直接执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// bind</span><br><span class="line">if ( !Function.prototype.bind )&#123;</span><br><span class="line">Function.prototype.bind = function(context)&#123;</span><br><span class="line">  if ( typeof this !== &apos;function&apos; )&#123;</span><br><span class="line">    console.log(&apos;this is not function&apos;);</span><br><span class="line">    throw new Error(&apos;this is not function&apos;);</span><br><span class="line">    return ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var args = Array.prototype.slice.call(arguments, 1),</span><br><span class="line">      self = this;</span><br><span class="line">  var tmpFunc = function()&#123;&#125;;           // 构造函数原型链继承</span><br><span class="line">  var mainFunc = function()&#123;</span><br><span class="line">      var innerArgs = Array.prototype.slice.call(arguments);  //改变上下文之后的arguments</span><br><span class="line">      var finalArgs = args.concat(innerArgs);</span><br><span class="line">      return self.apply(this instanceof tmpFunc ? this : context || window,finalArgs);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  tmpFunc.prototype = this.prototype;</span><br><span class="line">  mainFunc.prototype = new tmpFunc();</span><br><span class="line">  return mainFunc;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// call, apply</span><br><span class="line">Function.prototype.call = function(context)&#123;</span><br><span class="line">  var context = context || window;</span><br><span class="line">  context.fn = this;</span><br><span class="line">  var args = [];</span><br><span class="line">  for ( var i=0,len=arguments.length; i&lt;len; i++ )&#123;</span><br><span class="line">    args.push(&apos;arguments[&apos;+i+&apos;]&apos;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var res = eval(&apos;context.fn(&apos;+args+&apos;)&apos;);</span><br><span class="line">  delete conetxt.fn;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// apply</span><br><span class="line">Function.prototype.apply = function(context, argArr)&#123;</span><br><span class="line">  var context = context || window;</span><br><span class="line">  if ( !arr ) return this();</span><br><span class="line"></span><br><span class="line">  context.fn = this;</span><br><span class="line"></span><br><span class="line">  var args = [];</span><br><span class="line">  for ( var i=0,len=argArr.length; i&lt;len; i++ )&#123;</span><br><span class="line">    args.push(&apos;argArr[&apos;+i+&apos;]&apos;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var res = eval(&apos;context.fn(&apos;+args+&apos;)&apos;);</span><br><span class="line">  delete conetxt.fn;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;bind 返回一个函数， call apply 直接执行。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// bind&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if ( !Function.prototype.bind )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Function.prototype.bind = function(context)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  if ( typeof this !== &amp;apos;function&amp;apos; )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log(&amp;apos;this is not function&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    throw new Error(&amp;apos;this is not function&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  var args = Array.prototype.slice.call(arguments, 1),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      self = this;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  var tmpFunc = function()&amp;#123;&amp;#125;;           // 构造函数原型链继承&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  var mainFunc = function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      var innerArgs = Array.prototype.slice.call(arguments);  //改变上下文之后的arguments&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      var finalArgs = args.concat(innerArgs);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      return self.apply(this instanceof tmpFunc ? this : context || window,finalArgs);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  tmpFunc.prototype = this.prototype;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  mainFunc.prototype = new tmpFunc();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return mainFunc;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>实现继承inherit</title>
    <link href="http://yoursite.com/2019/05/04/%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BFinherit/"/>
    <id>http://yoursite.com/2019/05/04/实现继承inherit/</id>
    <published>2019-05-04T08:10:08.000Z</published>
    <updated>2019-05-04T08:15:52.820Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function Parent(name, value) &#123;</span><br><span class="line">  console.log(&apos;parent&apos;, name, value);</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.value = value;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.foo = function () &#123;</span><br><span class="line">  console.log(`$&#123;this.name&#125;--$&#123;this.value&#125;`);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function inherit(parentClass, &#123; property &#125;) &#123;</span><br><span class="line">  function Child() &#123;</span><br><span class="line">    console.log(&apos;child&apos;, arguments);</span><br><span class="line">    parentClass.apply(this, [].slice.call(arguments));</span><br><span class="line">  &#125;</span><br><span class="line">  // Child.prototype = parentClass.prototype, 避免Parent prototype 更新传递</span><br><span class="line">  // Child.prototype = new parentClass() 避免实例化两次parentClass</span><br><span class="line">  function tmp()&#123;&#125;</span><br><span class="line">  tmp.prototype = parentClass.prototype;</span><br><span class="line">  Child.prototype = new tmp();</span><br><span class="line">  Child.prototype.constructor = Child;     // constructor 指向</span><br><span class="line">  for (key in property) &#123;</span><br><span class="line">    Child.prototype[key] = property[key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return Child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const child = inherit(Parent, &#123;</span><br><span class="line">  property: &#123;</span><br><span class="line">    test() &#123; console.log(&apos;test&apos;); &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">const ch = new child(&apos;child&apos;, 123);</span><br><span class="line">ch.foo();</span><br><span class="line">ch.test();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function Parent(name, value) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.log(&amp;apos;parent&amp;apos;, name, value);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  this.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  this.value = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Parent.prototype.foo = function () &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.log(`$&amp;#123;this.name&amp;#125;--$&amp;#123;this.value&amp;#125;`);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function inherit(parentClass, &amp;#123; property &amp;#125;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  function Child() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log(&amp;apos;child&amp;apos;, arguments);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    parentClass.apply(this, [].slice.call(arguments));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  // Child.prototype = parentClass.prototype, 避免Parent prototype 更新传递&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  // Child.prototype = new parentClass() 避免实例化两次parentClass&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  function tmp()&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  tmp.prototype = parentClass.prototype;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Child.prototype = new tmp();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Child.prototype.constructor = Child;     // constructor 指向&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  for (key in property) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Child.prototype[key] = property[key];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return Child;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="继承inherit" scheme="http://yoursite.com/tags/%E7%BB%A7%E6%89%BFinherit/"/>
    
  </entry>
  
  <entry>
    <title>var let 箭头函数与普通函数</title>
    <link href="http://yoursite.com/2019/05/04/var-let-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/05/04/var-let-箭头函数与普通函数/</id>
    <published>2019-05-04T07:59:35.000Z</published>
    <updated>2019-05-04T08:14:52.524Z</updated>
    
    <content type="html"><![CDATA[<p>箭头函数对比普通函数：</p><ol><li>箭头函数没有this， 执行bind apply call 不能改变上下文</li><li>没有arguments</li><li>匿名函数，不能new 实例，没有prototype</li><li>不能作为generator函数，不能调用yeild</li></ol><a id="more"></a><p>let vs var:</p><ul><li>作用域不一样，var 函数作用域， let 是块作用域</li><li>let 不能重复声明， var可以多次声明</li><li>let 会暂时性死区，对应的var 会前置声明，造成变量提升</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;箭头函数对比普通函数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;箭头函数没有this， 执行bind apply call 不能改变上下文&lt;/li&gt;
&lt;li&gt;没有arguments&lt;/li&gt;
&lt;li&gt;匿名函数，不能new 实例，没有prototype&lt;/li&gt;
&lt;li&gt;不能作为generator函数，不能调用yeild&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>instanceOf</title>
    <link href="http://yoursite.com/2019/05/04/instanceOf/"/>
    <id>http://yoursite.com/2019/05/04/instanceOf/</id>
    <published>2019-05-04T07:51:42.000Z</published>
    <updated>2019-05-04T08:14:40.340Z</updated>
    
    <content type="html"><![CDATA[<p>instanceOf 的判断是基于原型链，即比对右侧表达式是否在左侧表达式的原型链上。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// instanceof</span><br><span class="line">function instance_of(L, R) &#123;//L 表示左表达式，R 表示右表达式</span><br><span class="line"> var O = R.prototype;// 取 R 的显示原型</span><br><span class="line"> L = L.__proto__;// 取 L 的隐式原型</span><br><span class="line"> while (true) &#123;</span><br><span class="line">   if (L === null)</span><br><span class="line">     return false;</span><br><span class="line">   if (O === L)// 这里重点：当 O 严格等于 L 时，返回 true</span><br><span class="line">     return true;</span><br><span class="line">   L = L.__proto__;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// some e.g</span><br><span class="line">Object.prototype.__proto__ -&gt; null</span><br><span class="line">Function.prototype.__proto__ -&gt; Object.prototype</span><br><span class="line">function Object()&#123;&#125;  function Function()&#123;&#125; __proto__ 都指向Function.prototype</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;instanceOf 的判断是基于原型链，即比对右侧表达式是否在左侧表达式的原型链上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>排序与树的遍历算法实现</title>
    <link href="http://yoursite.com/2019/03/02/%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/03/02/排序与树的遍历算法实现/</id>
    <published>2019-03-02T13:44:28.000Z</published>
    <updated>2019-05-04T08:16:36.661Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 冒泡</span><br><span class="line">function sort1(arr)&#123;</span><br><span class="line">  for ( let i=0, len=arr.length; i&lt;len-1; i++ )&#123;</span><br><span class="line">    for ( let j=i+1; j&lt;=len-1; j++ )&#123;</span><br><span class="line">      if ( arr[i] &gt; arr[j] )&#123;</span><br><span class="line">        let tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 插入</span><br><span class="line">function sort2(arr)&#123;</span><br><span class="line">  for ( let i=1, len=arr.length; i&lt;=len-1; i++ )&#123;</span><br><span class="line">    var tmp = arr[i];</span><br><span class="line">    for ( var j=i-1; j&gt;=0; j-- )&#123;</span><br><span class="line">      if ( arr[j] &gt; tmp )&#123;</span><br><span class="line">        arr[j+1] = arr[j];</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">        break ;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j+1] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 快排</span><br><span class="line">function part(arr, start, end)&#123;</span><br><span class="line">  let pivot = arr[start];</span><br><span class="line">  while (start &lt; end) &#123;</span><br><span class="line">    while (start &lt; end &amp;&amp; arr[end] &gt; pivot) &#123;</span><br><span class="line">      --end;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[start] = arr[end];</span><br><span class="line">    while (start &lt; end &amp;&amp; arr[start] &lt;= pivot) &#123;</span><br><span class="line">      ++start;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[end] = arr[start];</span><br><span class="line">  &#125;</span><br><span class="line">  arr[start] = pivot;</span><br><span class="line">  return start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function sort3(arr, start, end)&#123;</span><br><span class="line">  if ( start &gt;= end ) return arr;</span><br><span class="line">  let index = part(arr, start, end);</span><br><span class="line">  sort3(arr, start, index-1);</span><br><span class="line">  sort3(arr, index+1, end)</span><br><span class="line">  return arr;</span><br><span class="line">&#125;</span><br><span class="line">function sort(arr)&#123;</span><br><span class="line">  return sort3(arr,0,arr.length-1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">const tree = &#123;</span><br><span class="line">  value : 1,</span><br><span class="line">  children: [</span><br><span class="line">    &#123;value:&apos;1-1&apos;, children:[&#123;value:&apos;1-1-1&apos;,children:[]&#125;]&#125;,</span><br><span class="line">    &#123;value:&apos;1-2&apos;, children:[&#123;value:&apos;1-2-1&apos;, children:[&#123;value:&apos;1-2-1-1&apos;&#125;]&#125;,&#123;value:&apos;1-2-2&apos;,children:[]&#125;]&#125;,</span><br><span class="line">    &#123;value:&apos;1-3&apos;, children:[&#123;value:&apos;1-3-1&apos;&#125;,&#123;value:&apos;1-3-2&apos;&#125;]&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 广度优先</span><br><span class="line">function spread(tree)&#123;</span><br><span class="line">  var nodeArr = [];</span><br><span class="line">  var valArr = [];</span><br><span class="line"></span><br><span class="line">  nodeArr.push(tree);</span><br><span class="line">  while ( nodeArr.length &gt; 0 )&#123;</span><br><span class="line">    let node = nodeArr.shift();</span><br><span class="line">    valArr.push(node.value);</span><br><span class="line">    node.children &amp;&amp; node.children.map(v=&gt;&#123;</span><br><span class="line">      nodeArr.push(v);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  return valArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 深度优先</span><br><span class="line">function deep(tree)&#123;</span><br><span class="line">  let nodeArr = [], valArr = [];</span><br><span class="line">  nodeArr.push(tree);</span><br><span class="line">  while ( nodeArr.length &gt; 0 )&#123;</span><br><span class="line">    let node = nodeArr.shift();</span><br><span class="line">    valArr.push(node.value);</span><br><span class="line">    if ( node.children )&#123;</span><br><span class="line">      for ( let len=node.children.length-1; len&gt;=0 ;len-- )&#123;</span><br><span class="line">        nodeArr.unshift(node.children[len]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return valArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 冒泡&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function sort1(arr)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  for ( let i=0, len=arr.length; i&amp;lt;len-1; i++ )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for ( let j=i+1; j&amp;lt;=len-1; j++ )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      if ( arr[i] &amp;gt; arr[j] )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let tmp = arr[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        arr[i] = arr[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        arr[j] = tmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return arr;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>初次开发hybrid H5的坑及方案</title>
    <link href="http://yoursite.com/2019/03/02/%E5%88%9D%E6%AC%A1%E5%BC%80%E5%8F%91hybrid-H5%E7%9A%84%E5%9D%91%E5%8F%8A%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2019/03/02/初次开发hybrid-H5的坑及方案/</id>
    <published>2019-03-02T11:19:06.000Z</published>
    <updated>2019-05-04T07:47:06.698Z</updated>
    
    <content type="html"><![CDATA[<h4 id="hybrid-h5"><a href="#hybrid-h5" class="headerlink" title="hybrid h5"></a>hybrid h5</h4><p>hybrid 翻译为杂交， hyrid h5 是指将web前端页面嵌入到原生APP( iOS和Android )中的运行的方案。<br>相对于原生开发，web前端的开发发展时间更长、从业人员更多、生态更为繁荣，而且开发效率也更高。<br>但web并不能直接调用原生API，而且运行内存、调度也差与原生，流畅性就显得不足。<br>基于以上原因，协调开发资源，将一些展示性、交互不多的页面让web开发，嵌入原生Webview中运行，就可以大大提高APP开发效率，利用团队开发资源。</p><a id="more"></a><h4 id="h5调用原生方法"><a href="#h5调用原生方法" class="headerlink" title="h5调用原生方法"></a>h5调用原生方法</h4><p>参考 (<a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="noopener">https://github.com/marcuswestin/WebViewJavascriptBridge</a>)</p><ol><li>直接注入调用<br>iOS能访问Webview下全局对象window，所以可以将js方法挂载到window上，然后iOS调用；<br>安卓的话可以注入方法到window上，然后js调用这原生方法。</li><li>协议监听<br>原生API能拦截Webview的网络请求，url根据协议传参，原生解析后执行，将结果挂载到window上。<br>js的url实现方法：<br> 2.1 window.location.href<br> 2.2 利用页面中嵌套的iframe的url(将iframe的长宽都设为很小或者0，取到数据后再移除这个iframe)建议使用②iframe的方式，因为如果我们连续多次修改window.location.href的值，在Native层只能接收到最后一次请求，前面的请求都会被忽略掉。</li><li>引入JsBridge（安卓）和 WebViewJavascriptBridge（iOS）库的方案<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 安卓运行</span><br><span class="line">// 如果WebViewJavascriptBridge已挂载，直接执行，否则，等待WebViewJavascriptBridgeReady时间触发，即原生方法已挂载后执行</span><br><span class="line">if (window.WebViewJavascriptBridge) &#123;</span><br><span class="line">    //do your work here</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    document.addEventListener(</span><br><span class="line">        &apos;WebViewJavascriptBridgeReady&apos;</span><br><span class="line">        , function() &#123;</span><br><span class="line">            //do your work here</span><br><span class="line">        &#125;,</span><br><span class="line">        false</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// iOS运行</span><br><span class="line">function setupWebViewJavascriptBridge(callback) &#123;</span><br><span class="line">if (window.WebViewJavascriptBridge) &#123; return callback(WebViewJavascriptBridge); &#125;</span><br><span class="line">if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback); &#125;</span><br><span class="line">window.WVJBCallbacks = [callback];</span><br><span class="line">var WVJBIframe = document.createElement(&apos;iframe&apos;);</span><br><span class="line">WVJBIframe.style.display = &apos;none&apos;;</span><br><span class="line">WVJBIframe.src = &apos;https://__bridge_loaded__&apos;;</span><br><span class="line">document.documentElement.appendChild(WVJBIframe);</span><br><span class="line">setTimeout(function() &#123; document.documentElement.removeChild(WVJBIframe) &#125;, 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>此次项目，我们直接进行的注入调用。<br>h5中涉及到摄像头拍照的功能，由原生提供，注入到h5中，挂载到window.api上，js则可以直接调用方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.api.camera(params, function()&#123;&#125;)    // 调用原生注入的API，参数不可缺少，传递params参数以及回调函数</span><br></pre></td></tr></table></figure></p><p>html中引入一个固定名称的js文件供安卓注入，比如 android.js， 兼容安卓5，文件不能为空，所以可以声明一个无关紧要的变量或者console。</p><h4 id="兼容遇到的问题"><a href="#兼容遇到的问题" class="headerlink" title="兼容遇到的问题"></a>兼容遇到的问题</h4><ol><li>安卓5下需要对Promise reject进行处理，否在抛错</li><li>es6 spread语法， …obj， 低版本下需要确定obj为Object,如果为’’，会抛错</li><li>iOS调用js方法时，内部不能有Promise，否则会卡死，不执行回调</li><li>用iframe时，iOS会需要src同源，否则会解析失败</li><li>iOS input输入框，需要父元素position不是static，或者input{transform:translateZ(0)}</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;hybrid-h5&quot;&gt;&lt;a href=&quot;#hybrid-h5&quot; class=&quot;headerlink&quot; title=&quot;hybrid h5&quot;&gt;&lt;/a&gt;hybrid h5&lt;/h4&gt;&lt;p&gt;hybrid 翻译为杂交， hyrid h5 是指将web前端页面嵌入到原生APP( iOS和Android )中的运行的方案。&lt;br&gt;相对于原生开发，web前端的开发发展时间更长、从业人员更多、生态更为繁荣，而且开发效率也更高。&lt;br&gt;但web并不能直接调用原生API，而且运行内存、调度也差与原生，流畅性就显得不足。&lt;br&gt;基于以上原因，协调开发资源，将一些展示性、交互不多的页面让web开发，嵌入原生Webview中运行，就可以大大提高APP开发效率，利用团队开发资源。&lt;/p&gt;
    
    </summary>
    
    
      <category term="H5" scheme="http://yoursite.com/tags/H5/"/>
    
  </entry>
  
  <entry>
    <title>小程序探索</title>
    <link href="http://yoursite.com/2018/12/02/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%A2%E7%B4%A2/"/>
    <id>http://yoursite.com/2018/12/02/小程序探索/</id>
    <published>2018-12-02T08:12:46.000Z</published>
    <updated>2018-12-06T11:56:30.325Z</updated>
    
    <content type="html"><![CDATA[<h3 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h3><ul><li>小程序需要申请账号，主体可以是企业，也可以是个人，里面有小程序的AppID，配置服务地址(比如localhost)</li><li>小程序开发工具，创建工程需要AppID</li><li>开发工具包含代码编辑器+调试器+客户端模拟器+版本管理器，基本做到了一站式开发</li><li>模拟器只有ios和 nexus，再加上原生组件，真机调试不可少</li></ul><h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><p>整个框架像个大杂烩，整体设计并不统一，包含了OO、函数式和面向过程。或许，是为了不同技术栈背景的开发人员都能找到一套适合的开发模式。</p><ul><li>样式层上来看，wxss像个css的子集，缺少了一些特性支持</li><li>模板wxml来看，Mustache语法，类似ng1.js的语法，数据与视图绑定，但数据流不是双向，不是响应式，而是类似React语法的setData，异步单项数据流</li><li>逻辑层js中，Page(Object)类似于Vue1的data设置，逻辑方法写法，同时也包含生命周期函数，可直接访问路由</li><li>wxs和template可直接在wxml中扩展，分别对应了script和模板引擎，可在多个地方引入调用，虽然提供了组件，但开发并不是组件化</li></ul><hr>  <a id="more"></a><h5 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- pages </span><br><span class="line">  - pageA  </span><br><span class="line">    - pageA.js  </span><br><span class="line">    - pageA.wxml  </span><br><span class="line">    - pageA.wxss  </span><br><span class="line">    - pageA.json </span><br><span class="line">  - pageB  </span><br><span class="line">    - pageB.js  </span><br><span class="line">    - pageB.wxml  </span><br><span class="line">    - pageB.wxss  </span><br><span class="line">    - pageB.json</span><br><span class="line">- app.js</span><br><span class="line">- app.wxss</span><br><span class="line">- app.json</span><br></pre></td></tr></table></figure><p>.json 属于配置文件，.wxss 样式文件，.wxml模板，.js(.ts) 逻辑文件</p><p>app.json 是全局配置，pages下的页面配置，只有窗口window部分。</p><table><thead><tr><th>属性</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>pages</td><td style="text-align:center">页面路径入口列表 </td></tr><tr><td>window</td><td style="text-align:center">窗口样式 </td></tr><tr><td>tabBar</td><td style="text-align:center">底部tab </td></tr><tr><td>networkTimeout</td><td style="text-align:center">超时时间 </td></tr><tr><td>debug</td><td style="text-align:center">是否开启debug，默认关闭 </td></tr><tr><td>functionalPages</td><td style="text-align:center">是否启用插件，默认关闭 </td></tr><tr><td>subpackages</td><td style="text-align:center">分包结构配置 </td></tr><tr><td>workers</td><td style="text-align:center">Worker放置目录 </td></tr><tr><td>requiredBackgroundModes</td><td style="text-align:center">需要在后台使用的能力，如音乐播放 </td></tr><tr><td>plugins</td><td style="text-align:center">使用的插件 </td></tr><tr><td>preloadRule</td><td style="text-align:center">分包预下载规则 </td></tr><tr><td>resizable</td><td style="text-align:center">iPad下是否直接屏幕旋转，默认关闭 </td></tr><tr><td>navigateToMiniProgramAppIdList</td><td style="text-align:center">需要跳转的小程序列表 </td></tr><tr><td>usingComponents</td><td style="text-align:center">全局自定义组件配置 </td></tr></tbody></table><p>pages类似于路由，配置页面的入口路径， 例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;pages&quot;:[ </span><br><span class="line">  &quot;pages/pageA/pageA&quot;, </span><br><span class="line">  &quot;pages/pageB/pageB&quot;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><h5 id="逻辑层"><a href="#逻辑层" class="headerlink" title="逻辑层"></a>逻辑层</h5><ul><li>App(Object) 注册App, Page(Object) 注册页面</li><li>data:{}, 初始数据</li><li>Page.route, 得到当前页面路径</li><li>Page.prototype.setData(data, function(){}),更新page中的data</li><li>生命周期函数，onLoad()：页面加载时触发，onShow()：页面显示时触发，onReady()：页面初次渲染完成是触发，onHide()：页面隐藏时触发，onUnload()：页面卸载时触发</li></ul><h5 id="视图层"><a href="#视图层" class="headerlink" title="视图层"></a>视图层</h5><p><strong>wxml</strong> 类似于html，用于页面结构，数据绑定是Mustache语法，类似于ng1.js。</p><p>列表渲染<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 默认下标为index，默认值为item</span><br><span class="line">// 可以用wx:for-index, wx:for-item 自定义</span><br><span class="line">&lt;view wx:for=&quot;&#123;&#123;array&#125;&#125;&quot; wx:for-index=&quot;cusIndex&quot; wx:for-item=&quot;cusItem&quot;&gt;</span><br><span class="line">&#123;&#123;cusItem&#125;&#125;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure></p><p>条件渲染<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;view wx:if=&quot;&#123;&#123;condition&#125;&#125;&quot;&gt;condition is true&lt;/view&gt;</span><br><span class="line">&lt;view wx:elif=&quot;&#123;&#123;condition2&#125;&#125;&quot;&gt;condition2 is true&lt;/view&gt;</span><br><span class="line">&lt;view wx:else&gt;else case&lt;/view&gt;</span><br></pre></td></tr></table></figure></p><p>模板 template，有点类似之前的各种模板引擎，比如handlebars,artTemplate，就是定义一段代码片段，方便在多个地方多次调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个模板，名称为 tmpName</span><br><span class="line">&lt;template name=&quot;tmpName&quot;&gt;</span><br><span class="line">// wxml code</span><br><span class="line">&lt;text&gt;&#123;&#123;a&#125;&#125;&lt;/text&gt;</span><br><span class="line">&lt;text&gt;&#123;&#123;b&#125;&#125;&lt;/text&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">// 使用模板tmpName, 传参 data: &#123; obj:&#123;a:1,b:2&#125; &#125;</span><br><span class="line">&lt;template is=&quot;tmpName&quot; data=&quot;&#123;&#123;...obj&#125;&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>模板有作用域，只能使用data传参的数据，或模板中<wxs>导出的模块数据。</wxs></p><p>事件绑定的写法同组件的属性，以 key、value 的形式。</p><ul><li>key 以bind或catch开头，然后跟上事件的类型，如bindtap、catchtouchstart。自基础库版本 1.5.0 起，在<strong>非原生组件</strong>中，bind和catch后可以紧跟一个冒号，其含义不变，如bind:tap、catch:touchstart。</li><li>value 是一个字符串，需要在对应的 Page 中定义同名的函数。不然当触发事件的时候会报错。</li><li>catch事件绑定可以阻止冒泡事件向上冒泡，capture-catch关键字，将中断捕获阶段和取消冒泡阶段</li><li><strong>原生组件</strong>的事件监听不能使用 bind:eventname 的写法，只支持 bindeventname。原生组件也不支持 catch 和 capture 的事件绑定方式。</li></ul><p>引用包括<code>import</code> <code>include</code>两种方式，又是以前的资源模板用法。<br>import只引入目标中定义的模板，不包含目标文件中import的模板, <import src=""> 引入。<br>include包含目标文件中除了<code>&lt;template&gt;&lt;/template&gt; &lt;wxs /&gt;</code>外的整个代码块，但会解析模板中的<code>&lt;template is=&quot;&quot; /&gt;， &lt;include src=&quot;&quot; /&gt;</code>引入。</import></p><hr><p><strong>wxss</strong> 可以看做”wx css”。相比css，增加了尺寸单位rpx。<br>选择器也有变化，支持class id element和伪类::before,::after， 不支持:hover :nth-child :focus等伪类， 不支持兄弟选择器。</p><hr><p><strong>wsx</strong> 类似于 <code>&lt;script&gt;</code>，是wxml模板中的脚本。示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;wxs module=&quot;m1&quot;&gt;</span><br><span class="line">var msg = &quot;hello world&quot;;</span><br><span class="line"></span><br><span class="line">module.exports.message = msg;</span><br><span class="line">&lt;/wxs&gt;</span><br><span class="line"></span><br><span class="line">&lt;view&gt; &#123;&#123;m1.message&#125;&#125; &lt;/view&gt;</span><br></pre></td></tr></table></figure></p><ul><li>wxs 的运行环境和其他 javascript 代码是隔离的，wxs 中不能调用其他 javascript 文件中定义的函数，也不能调用小程序提供的API。</li><li>wxs 函数不能作为组件的事件回调。</li><li>wxs 如果module和exports和data中的数据重名，将会覆盖</li><li>.wxs文件可以被其他模块require引入</li></ul><hr><p>分包加载是将小程序划分成不同的子包，在构建时打包成不同的分包，用户在使用时按需进行加载，需要在app.json中的subpackages中配置。</p><table><thead><tr><th>字段</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td>root</td><td style="text-align:center">分包根目录 </td></tr><tr><td>name</td><td style="text-align:center">分包别名，分包预下载时可以使用 </td></tr><tr><td>pages</td><td style="text-align:center">分包页面路径 </td></tr><tr><td>independent</td><td style="text-align:center">是否是独立分包 </td></tr></tbody></table><ul><li>tabBar页面必须在主包app内</li><li>分包的根目录必须分开，不能嵌套</li><li>分包之间不能相互import require资源</li></ul><hr><h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><h5 id="视图容器"><a href="#视图容器" class="headerlink" title="视图容器"></a>视图容器</h5><p>提供了外层基本容器View，覆盖容器cover-view，还有常用的轮播图swiper。<br>更注重block容器，没有行内的grid、flex。</p><h5 id="基础内容"><a href="#基础内容" class="headerlink" title="基础内容"></a>基础内容</h5><p>仅有9种icon… text相当于span，属于inline， 还有一个有用的progress进度条。</p><h5 id="表单组件"><a href="#表单组件" class="headerlink" title="表单组件"></a>表单组件</h5><p>包含常用的 button checkbox radio swtich， 还有input textarea， 没有类似table list的组件。<br>picker包含了单选项select功能，还有级联cascader功能，以及时间 timepicker， 日期datepicker，没有时间范围选择功能。</p><h5 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h5><p>navigator跳转，可以满足当前小程序的跳转，也可以跳转到其他小程序</p><h5 id="媒体、地图、画布"><a href="#媒体、地图、画布" class="headerlink" title="媒体、地图、画布"></a>媒体、地图、画布</h5><p>包括 video、image、camera等媒体组件，map、canvas是原生组件。</p><hr><p>小程序的组件库不多，但对于手机端还算足够用。封装了使用频次较高的swiper，picker，但资源型组件，比如icon，内容实在太少。此外，还有<strong>原生组件</strong>的限制，参考<a href="https://developers.weixin.qq.com/miniprogram/dev/component/native-component.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/component/native-component.html</a> 。</p><hr><h4 id="配置ts自动编译"><a href="#配置ts自动编译" class="headerlink" title="配置ts自动编译"></a>配置ts自动编译</h4><ol start="0"><li>前置，需要npm安装typescript</li><li><p>在package.json “scripts”中增加ts文件监听指令 “watch”: “tsc -w”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">&quot;tsc&quot;: &quot;./node_modules/typescript/bin/tsc&quot;,</span><br><span class="line">&quot;compile&quot;: &quot;tsc&quot;,</span><br><span class="line">&quot;watch&quot;: &quot;tsc -w&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>增加编译模式，入口是page/index/index,参数为指令名称watch</p></li><li>然后编译模式，切换到新增的编译模式</li></ol><hr><h5 id="衍生的框架"><a href="#衍生的框架" class="headerlink" title="衍生的框架"></a>衍生的框架</h5><p>wepy <a href="https://github.com/Tencent/wepy" target="_blank" rel="noopener">https://github.com/Tencent/wepy</a></p><p>腾讯出的框架，小程序组件化框架，15k+star</p><p>总结要点:</p><ul><li>类Vue开发风格，组件化 es6 es7， wepy-cli</li><li>小程序细节优化，如请求列队，事件优化等</li></ul><p>缺点：</p><ul><li>脏值检测封装setData，上一个这样做的ng1,性能堪忧</li><li>类Vue，但开发体验不好</li><li>基础组件问题多</li></ul><hr><p>mpvue <a href="https://github.com/Meituan-Dianping/mpvue" target="_blank" rel="noopener">https://github.com/Meituan-Dianping/mpvue</a></p><p>美团开发，基于 Vue.js 的小程序开发框架，从底层支持 Vue.js 语法和构建工具体系， 14.5k+star</p><ul><li>相比wepy, 完整的 Vue.js 开发体验</li><li>彻底的组件化开发能力</li><li>H5 代码转换编译成小程序目标代码的能力</li></ul><p>缺点：<br>有且只能使用单文件组件（.vue 组件）的形式进行支持，详细的不支持列表.</p><ul><li>不支持 纯-HTML</li><li>不支持过滤器</li><li>不支持函数</li><li>暂不支持在组件引用时，在组件上定义 click 等原生事件、v-show（可用 v-if 代替）和 class style 等样式属性</li><li>Slot（scoped 暂时还没做支持）</li><li>动态组件</li><li>异步组件</li><li>inline-template</li><li>X-Templates</li><li>keep-alive</li><li>transition</li><li>class</li><li>style</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;微信小程序&quot;&gt;&lt;a href=&quot;#微信小程序&quot; class=&quot;headerlink&quot; title=&quot;微信小程序&quot;&gt;&lt;/a&gt;微信小程序&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;小程序需要申请账号，主体可以是企业，也可以是个人，里面有小程序的AppID，配置服务地址(比如localhost)&lt;/li&gt;
&lt;li&gt;小程序开发工具，创建工程需要AppID&lt;/li&gt;
&lt;li&gt;开发工具包含代码编辑器+调试器+客户端模拟器+版本管理器，基本做到了一站式开发&lt;/li&gt;
&lt;li&gt;模拟器只有ios和 nexus，再加上原生组件，真机调试不可少&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;框架&quot;&gt;&lt;a href=&quot;#框架&quot; class=&quot;headerlink&quot; title=&quot;框架&quot;&gt;&lt;/a&gt;框架&lt;/h4&gt;&lt;p&gt;整个框架像个大杂烩，整体设计并不统一，包含了OO、函数式和面向过程。或许，是为了不同技术栈背景的开发人员都能找到一套适合的开发模式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;样式层上来看，wxss像个css的子集，缺少了一些特性支持&lt;/li&gt;
&lt;li&gt;模板wxml来看，Mustache语法，类似ng1.js的语法，数据与视图绑定，但数据流不是双向，不是响应式，而是类似React语法的setData，异步单项数据流&lt;/li&gt;
&lt;li&gt;逻辑层js中，Page(Object)类似于Vue1的data设置，逻辑方法写法，同时也包含生命周期函数，可直接访问路由&lt;/li&gt;
&lt;li&gt;wxs和template可直接在wxml中扩展，分别对应了script和模板引擎，可在多个地方引入调用，虽然提供了组件，但开发并不是组件化&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="小程序" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>BizCharts调研</title>
    <link href="http://yoursite.com/2018/11/29/BizCharts%E8%B0%83%E7%A0%94/"/>
    <id>http://yoursite.com/2018/11/29/BizCharts调研/</id>
    <published>2018-11-29T12:13:36.000Z</published>
    <updated>2018-12-06T11:56:37.260Z</updated>
    
    <content type="html"><![CDATA[<h4 id="BizCharts"><a href="#BizCharts" class="headerlink" title="BizCharts"></a>BizCharts</h4><p>官网：<a href="https://bizcharts.net/" target="_blank" rel="noopener">https://bizcharts.net/</a></p><p>简单说下特性:</p><ul><li>基于 G2 封装的 React 图表库，具有 G2、React 的全部优点，可以让用户以组件的形式组合出无数种图表</li><li>集成了大量的统计工具，支持多种坐标系绘制，交互定制，动画定制以及图形定制等</li><li>性能稳定且具有强大的扩展能力和高度自定义能力</li></ul><hr><a id="more"></a><h4 id="和ECharts对比"><a href="#和ECharts对比" class="headerlink" title="和ECharts对比"></a>和ECharts对比</h4><ul><li>ECharts是一个基本库，不依赖其他框架，在React/Vue/Angular中都可以使用。 BizCharts是基于G2的封装，组件的解析依赖于React。</li><li>ECharts是配置型，绝大部分展示交互通过配置options完成; BizCharts是编码型，提供了图表构成的各部分组件，引入组件来绘制图表</li><li>ECharts由百度开源，从2013.6至今，版本从1.0到4.2，包含了24种平面图和10种基于webGL的3D图，实现了多渲染方案(canvas,svg,vml)、跨平台使用，各种功能十分丰富； Bizcharts由ali开源，从2017.12月直接发布3.0版本，至今版本3.2，包含了14种图例，支持canvas,svg渲染方案，仅针对PC端，平台端分离出BizGoblin，功能配置项较ECharts少。</li><li>BizCharts部分功能不完备，例如resize，需要主动由window dispatch resize, 多Y轴需要用Dataset展开，排序没有默认转为数值，需要手动将字符串转为数值。</li><li>性能上，数据量不大的情况下，两者都可以接受。但ECharts有重构底层图形库ZRender,针对移动端优化，所以性能上更好。在图表中自定义一部分dom结构，同样的逻辑，ECharts流畅性能高。</li></ul><h4 id="体验改进"><a href="#体验改进" class="headerlink" title="体验改进"></a>体验改进</h4><p>G2 会将打点监控，默认会将 URL 等信息发送回 AntV 服务器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">url: https://kcart.alipay.com/web/bi.do</span><br><span class="line">param:&#123; </span><br><span class="line">    BIProfile:merge, </span><br><span class="line">    d:[&#123;&quot;bizcharts&quot;:&quot;3.2.5-beta.3&quot;,&quot;pg&quot;:&quot;http://localhost:3000/#/app/2495489/performance/web&quot;,&quot;r&quot;:1541569473246,&quot;g2&quot;:true,&quot;version&quot;:&quot;3.3.3&quot;,&quot;page_type&quot;:&quot;syslog&quot;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br><span class="line">设置track(false)可以关闭。</span><br><span class="line"></span><br><span class="line">BizCharts.track(false);// orimport &#123; track &#125; from &apos;bizcharts&apos;;track(false)常用组件</span><br></pre></td></tr></table></figure></p><hr><h4 id="Chart"><a href="#Chart" class="headerlink" title="Chart"></a>Chart</h4><p>图表最顶级的组件，控制着图表的创建、绘制、销毁等。</p><ul><li>renderer 图表渲染方式，默认为canvas，可设置为svg</li><li>data 图表数据源，JSON对象数组或者DataSet.View对象</li><li>scale 配置图表比例尺, 例如将Y轴设置为从0开始</li><li>padding 默认为’auto’, 比如设置左侧和下面的padding, padding={[‘auto’, ‘auto’, 20, 20]}</li><li>事件支持 <code>onPlotClick</code> 点击， <code>onTooltipChange</code> tooltip变化， <code>onPlotEnter</code>鼠标进入绘图区域等</li></ul><h4 id="Axis"><a href="#Axis" class="headerlink" title="Axis"></a>Axis</h4><p>坐标轴组件，控制图表中坐标轴的样式等。</p><ul><li>name 坐标轴对应数据源的字段key</li><li>label Object对象，{textStyle:{}, formatter(text,item,index){} …}，可设置坐标轴格式及样式等</li></ul><h4 id="Geom"><a href="#Geom" class="headerlink" title="Geom"></a>Geom</h4><p>几何标记对象，决定创建图表的类型。</p><ul><li>type 几何标记类型，有line(线图) interval(柱状图、饼图) area(区域图) edge(树图、关系图等)等</li><li>color 将数据值映射到图形的颜色, 可以是数据字段key,配合Legend组件显示，也可以是[field,[color1,color2]]的颜色映射</li><li>position 位置属性的映射，格式为 “a*b”，a字段对应横轴，b字段对应纵轴</li><li>tooltip 显示图标数据点的提示信息, 格式为<code>[&#39;a*b&#39;, (a,b)=&gt;({name:xx, value:yyy})]</code></li></ul><h4 id="Legend"><a href="#Legend" class="headerlink" title="Legend"></a>Legend</h4><p>图例。</p><ul><li>position 图例位置，默认为 ‘buttom-center’</li><li>layout 图例排列方式，vertical、horizontal</li><li>itemFormatter 图例文本展示</li></ul><h4 id="Tooltip"><a href="#Tooltip" class="headerlink" title="Tooltip"></a>Tooltip</h4><p>tooltip显示信息层</p><ul><li>triggerOn 触发形式，mousemove click none</li><li>crosshairs Object对象，tooltip辅助线样式，如{type:’line’, style:{}}</li></ul><h4 id="Slider"><a href="#Slider" class="headerlink" title="Slider"></a>Slider</h4><p>需要单独安装，<code>npm install bizcharts-plugin-slider</code>，作用与 ECharts <code>dataZoom</code> 类似，可以局部展示图表信息</p><h4 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h4><p>Dataset需要单独安装 <code>npm install @antv/data-set -save</code><br>Dataset Transform 包含很多数据转换，如sort, map, filter等静态处理，也有fold形变处理，还包括树hierarchy, 图diagram处理，可以利用 hierarchy 树形排列数据点，作用类似于包 <code>d3-hierarchy</code> 。</p><p>注意点Tips</p><ul><li>Geom中tooltip字段格式，’a<em>b</em>c’ 符号为 ‘ *</li><li>Geom中color可以为映射的字段名，也可以为颜色，如果颜色和字段名同名，将导致图表刷新切换，不稳定。</li><li>图表resize是监听的window resize事件，所以需要在区域联动变化时手动dispatch事件， window.dispatchEvent(new Event(‘resize’));  (<a href="https://github.com/alibaba/BizCharts/issues/75" target="_blank" rel="noopener">https://github.com/alibaba/BizCharts/issues/75</a>)</li><li>Bizcharts中没有Geom指定Y轴的接口，所以需要用DataView合并使用同一Y轴的数据  (<a href="https://github.com/alibaba/BizCharts/issues/591" target="_blank" rel="noopener">https://github.com/alibaba/BizCharts/issues/591</a>)</li><li>Y轴排序使用的js自动排序，所以 toFix 保留的字符串需要转化为数值。 (<a href="https://github.com/alibaba/BizCharts/issues/330" target="_blank" rel="noopener">https://github.com/alibaba/BizCharts/issues/330</a>)</li><li>Bizcharts提供的图表组件，可以在Chart内部使用自定义的组件或者html dom</li><li>Axis组件的横纵由Geom的position决定，跟组件顺序无关</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">import DataSet from &apos;@antv/data-set&apos;;</span><br><span class="line">// ...</span><br><span class="line">render() &#123; </span><br><span class="line">    const ds = new DataSet(); </span><br><span class="line">    const dv = ds.createView().source(this.bchart || []); </span><br><span class="line">    dv.transform(&#123;  // fold展开字段 </span><br><span class="line">        type: &apos;fold&apos;, </span><br><span class="line">        fields: [&apos;count4xx&apos;, &apos;count5xx&apos;], </span><br><span class="line">        key: &apos;count&apos;, </span><br><span class="line">        value: &apos;errCount&apos;, // value字段 </span><br><span class="line">    &#125;); </span><br><span class="line">    dv.transform(&#123; </span><br><span class="line">        type: &apos;fold&apos;, </span><br><span class="line">        fields: [&apos;count4xx_percent&apos;, &apos;count5xx_percent&apos;], </span><br><span class="line">        key: &apos;percent&apos;, </span><br><span class="line">        value: &apos;errPercent&apos;, // value字段 </span><br><span class="line">    &#125;); </span><br><span class="line">    return </span><br><span class="line">    ( </span><br><span class="line">        &lt;Chart </span><br><span class="line">          height=&#123;300&#125; </span><br><span class="line">          data=&#123;dv&#125; </span><br><span class="line">          forceFit </span><br><span class="line">          padding=&#123;[&apos;auto&apos;, 60, &apos;auto&apos;, &apos;auto&apos;]&#125; </span><br><span class="line">          scale=&#123;&#123; name: &#123; alias: &apos;时间&apos;, type: &apos;time&apos;, mask: &apos;YYYY-MM-DD HH:mm:ss&apos; &#125; &#125;&#125; //name存储时间戳，设置name字段的展示格式 </span><br><span class="line">          onPlotClick=&#123;this.errClick&#125; // 事件处理 </span><br><span class="line">          onTooltipChange=&#123;this.toolShow&#125; </span><br><span class="line">        &gt; </span><br><span class="line">          &lt;Axis name=&quot;name&quot; /&gt; </span><br><span class="line">          &lt;Axis name=&quot;errCount&quot; /&gt; // fold 展开的两个字段共用一个Y轴 </span><br><span class="line">          &lt;Axis name=&quot;errPercent&quot; label=&#123;&#123; formatter(percent) &#123; return `$&#123;(+percent * 100).toFixed(1)&#125; %`; &#125; &#125;&#125; /&gt; </span><br><span class="line">          &lt;Legend </span><br><span class="line">            position=&quot;top-center&quot; </span><br><span class="line">            itemFormatter=&#123;v =&gt; (&#123; // legend 文本格式 count4xx: &apos;4xx错误数&apos;,      count5xx: &apos;5xx错误数&apos;, count4xx_percent: &apos;4xx错误率&apos;,                count5xx_percent: &apos;5xx错误率&apos;, &#125;[v])&#125; </span><br><span class="line">          /&gt; </span><br><span class="line">          &lt;Tooltip crosshairs=&#123;&#123; type: &apos;line&apos;, &#125;&#125; /&gt; </span><br><span class="line">          &lt;Geom type=&quot;interval&quot; // interval可展示bar图 color=&quot;count&quot; // 颜色对应fold处理后的key:count </span><br><span class="line">            position=&quot;name*errCount&quot; </span><br><span class="line">            tooltip=&#123;[&apos;name*count*errCount&apos;, (name, count, val) =&gt; (&#123; name: &#123; count4xx: &apos;4xx错误数&apos;, count5xx: &apos;5xx错误数&apos; &#125;[count], value: val &#125;)]&#125; </span><br><span class="line">          /&gt; </span><br><span class="line">          &lt;Geom </span><br><span class="line">            type=&quot;line&quot; // line图 color=&quot;percent&quot; </span><br><span class="line">            position=&quot;name*errPercent&quot; // position确定横纵坐标轴展示的数据字段 tooltip=&#123;[&apos;name*percent*errPercent&apos;, (name, key, val) =&gt; (&#123; </span><br><span class="line">              name: &#123; count4xx_percent: &apos;4xx错误率&apos;, count5xx_percent: &apos;5xx错误率&apos; &#125;[key], </span><br><span class="line">              value: `$&#123;(val * 100).toFixed(2)&#125;%` &#125;)</span><br><span class="line">            ]&#125; </span><br><span class="line">          /&gt; </span><br><span class="line">          // 自定义组件，可以直接在Chart中，此处模仿实现，抓取错误趋势数据 </span><br><span class="line">          &lt;div //eslint-disable-line </span><br><span class="line">            onMouseLeave=&#123;() =&gt; &#123; this.setState(&#123; confirmShow: false, errList: null &#125;); &#125;&#125; </span><br><span class="line">            style=&#123;&#123; display: (this.state.confirmShow ? &apos;block&apos; : &apos;none&apos;) &#125;</span><br><span class="line">          &lt;div style=&#123;&#123; </span><br><span class="line">                position: &apos;absolute&apos;, </span><br><span class="line">                background: &apos;#fff&apos;, </span><br><span class="line">                border: &apos;1px solid #ccc&apos;, </span><br><span class="line">                width: 300, </span><br><span class="line">                height: 80, </span><br><span class="line">                zIndex: 2, </span><br><span class="line">                top: this.state.position ? this.state.position[1] + 20 : 0, left: this.state.position ? this.state.position[0] - 150 : 0, </span><br><span class="line">                &#125;&#125; </span><br><span class="line">          &gt; </span><br><span class="line">          &#123;!this.state.errList ? </span><br><span class="line">            &lt;div&gt; </span><br><span class="line">              &lt;h4&gt;是否确认获取错误数&lt;/h4&gt; </span><br><span class="line">              &lt;Button onClick=&#123;this.confirmList&#125;&gt;确认&lt;/Button&gt; </span><br><span class="line">              &lt;Button onClick=&#123;() =&gt; this.setState(&#123; confirmShow: false &#125;)&#125;&gt;取消&lt;/Button&gt; </span><br><span class="line">            &lt;/div&gt; </span><br><span class="line">            : </span><br><span class="line">            &lt;div&gt;&#123;this.state.errList&#125;&lt;/div&gt; &#125; &lt;/div&gt; </span><br><span class="line">          &lt;/div&gt; </span><br><span class="line">      &lt;/Chart&gt; </span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;BizCharts&quot;&gt;&lt;a href=&quot;#BizCharts&quot; class=&quot;headerlink&quot; title=&quot;BizCharts&quot;&gt;&lt;/a&gt;BizCharts&lt;/h4&gt;&lt;p&gt;官网：&lt;a href=&quot;https://bizcharts.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://bizcharts.net/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单说下特性:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于 G2 封装的 React 图表库，具有 G2、React 的全部优点，可以让用户以组件的形式组合出无数种图表&lt;/li&gt;
&lt;li&gt;集成了大量的统计工具，支持多种坐标系绘制，交互定制，动画定制以及图形定制等&lt;/li&gt;
&lt;li&gt;性能稳定且具有强大的扩展能力和高度自定义能力&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="图表库" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%A1%A8%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>关于ECharts_click事件的探索</title>
    <link href="http://yoursite.com/2018/09/16/%E5%85%B3%E4%BA%8EECharts-click%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%8E%A2%E7%B4%A2/"/>
    <id>http://yoursite.com/2018/09/16/关于ECharts-click事件的探索/</id>
    <published>2018-09-16T04:19:35.000Z</published>
    <updated>2018-09-16T06:03:16.091Z</updated>
    
    <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>用echarts展示图表的时候，有时候需要点击当前图表，进行一些其他”effect side”操作,这个时候就需要得到当前这个点的横纵坐标的数据信息了。</p><hr><h4 id="探索方法"><a href="#探索方法" class="headerlink" title="探索方法"></a>探索方法</h4><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>查看官网API文档 <a href="http://www.echartsjs.com/api.html#echarts" target="_blank" rel="noopener">http://www.echartsjs.com/api.html#echarts</a>, 支持鼠标click事件，拿到基础的 line bar 图例上试验。<br>发现click触发条件是：</p><ol><li>line图需要点击到数据气泡点上，需要精准点击，数据多的时候，精准点击是困难的</li><li>bar图需要点击到柱状上，如果某几个数据bar很小，也存在精准点击困难的问题</li></ol><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>官网给出的API方法不尽如人意，去github上查找issue，发现有不少提出这问题。<br>解决方法：给出一个透明的bar坐标系重叠到图表上，透明bar的数据都是当前最大值，这样在图表对应的x轴都能实现触发点击，类似于tooltip那样方便。<br><a href="https://github.com/apache/incubator-echarts/issues/6106" target="_blank" rel="noopener">https://github.com/apache/incubator-echarts/issues/6106</a></p><p>但是，这个方法也有缺点：<br><a id="more"></a></p><ol><li>多了一个坐标系，增加了页面的数据量，加大了浏览器绘制压力</li><li>数据量大的时候，每个bar区域很小，bar之间存在空隙，准确点击也不那么容易</li></ol><p>所以，这个方法体验也不是那么好</p><h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h4><p>在试验方法二的时候，虽然准确点击体验不那么好，但hover触发的tooltip仍然十分流畅，但查看文档，tooltip虽然可以得到当前坐标的data数据，但无法判断事件。<br>所以想要tooltip那种点击得到当前数据的体验，需要结合一个click事件。</p><p>在官网示例上，找到一个click的示例， <a href="http://echarts.baidu.com/examples/editor.html?c=line-pen" target="_blank" rel="noopener">http://echarts.baidu.com/examples/editor.html?c=line-pen</a></p><p>zr的click在点击整个chart区域的时候都会触发，但往往需要排除掉图表区域外的无关区域，所以需要<code>convertFromPixel</code>转化到当前的坐标系，<code>containPixel</code>判断是否在当前坐标系中。<br>坐标点的数据呢？ 在tooltip的formatter中维护。 逻辑示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var clickParams = null;</span><br><span class="line">myChart.options.tooltip.formatter = function(params)&#123;</span><br><span class="line">    clickParams = params;</span><br><span class="line">    // return formaater string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var zr = myChart.getZr();</span><br><span class="line">zr.on(&apos;click&apos;, function (params) &#123;</span><br><span class="line">    var pointInPixel = [params.offsetX, params.offsetY];   //得到点击事件的触发点</span><br><span class="line">    var pointInGrid = myChart.convertFromPixel(&apos;grid&apos;, pointInPixel);</span><br><span class="line"></span><br><span class="line">    if (myChart.containPixel(&apos;grid&apos;, pointInPixel)) &#123;  //判断是否在坐标系中</span><br><span class="line">        // 得到clickParams， effect side 处理</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>issue讨论：<a href="https://github.com/apache/incubator-echarts/issues/3853" target="_blank" rel="noopener">https://github.com/apache/incubator-echarts/issues/3853</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h4&gt;&lt;p&gt;用echarts展示图表的时候，有时候需要点击当前图表，进行一些其他”effect side”操作,这个时候就需要得到当前这个点的横纵坐标的数据信息了。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;探索方法&quot;&gt;&lt;a href=&quot;#探索方法&quot; class=&quot;headerlink&quot; title=&quot;探索方法&quot;&gt;&lt;/a&gt;探索方法&lt;/h4&gt;&lt;h4 id=&quot;方法一&quot;&gt;&lt;a href=&quot;#方法一&quot; class=&quot;headerlink&quot; title=&quot;方法一&quot;&gt;&lt;/a&gt;方法一&lt;/h4&gt;&lt;p&gt;查看官网API文档 &lt;a href=&quot;http://www.echartsjs.com/api.html#echarts&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.echartsjs.com/api.html#echarts&lt;/a&gt;, 支持鼠标click事件，拿到基础的 line bar 图例上试验。&lt;br&gt;发现click触发条件是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;line图需要点击到数据气泡点上，需要精准点击，数据多的时候，精准点击是困难的&lt;/li&gt;
&lt;li&gt;bar图需要点击到柱状上，如果某几个数据bar很小，也存在精准点击困难的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;方法二&quot;&gt;&lt;a href=&quot;#方法二&quot; class=&quot;headerlink&quot; title=&quot;方法二&quot;&gt;&lt;/a&gt;方法二&lt;/h4&gt;&lt;p&gt;官网给出的API方法不尽如人意，去github上查找issue，发现有不少提出这问题。&lt;br&gt;解决方法：给出一个透明的bar坐标系重叠到图表上，透明bar的数据都是当前最大值，这样在图表对应的x轴都能实现触发点击，类似于tooltip那样方便。&lt;br&gt;&lt;a href=&quot;https://github.com/apache/incubator-echarts/issues/6106&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/apache/incubator-echarts/issues/6106&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但是，这个方法也有缺点：&lt;br&gt;
    
    </summary>
    
    
      <category term="echarts" scheme="http://yoursite.com/tags/echarts/"/>
    
  </entry>
  
  <entry>
    <title>记线上webpack分模块加载失败的问题</title>
    <link href="http://yoursite.com/2018/08/26/webpack%E5%88%86%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/08/26/webpack分模块加载失败的问题/</id>
    <published>2018-08-26T12:17:20.000Z</published>
    <updated>2018-09-16T06:03:31.866Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题一："><a href="#问题一：" class="headerlink" title="问题一："></a>问题一：</h3><p>用公司前端架构组给的tools工具时，在test环境下容易出现模块加载错误的问题。<br>观察发现，index.html， main.[hash].js 等资源文件缓存304， 各个路由页面引用的还是之前的hash资源，导致Jenkins新构建的资源没有被使用，而原来的资源已经被替换，找不到文件，所以出错。</p><p>将index.html 不缓存，每次 200 请求最新的，从而刷新各个资源文件。</p><h3 id="问题二："><a href="#问题二：" class="headerlink" title="问题二："></a>问题二：</h3><p>现象同样是加载失败。<br>区别1： 只有部分页面加载失败<br>区别2： 手动刷新，有时候页面又是好的，但另一个页面出问题。<br><a id="more"></a></p><p>发现在头部的script区域，路由请求资源时，请求的资源名不是对应的。例如： 页面A资源a.ja， 页面B资源b.js。<br>现象是： 进入A页面请求了b.js，B页面请求了a.js，资源出现了乱序。</p><p>再manifest中发现，fest的对应的key都是自增的数字id， 即<code>{1: &#39;a.js&#39;, 2:&#39;b.js&#39; ...}</code>。</p><p><strong>manifest标记了各个路由对应的js文件，但并不能保证每次打包编译是按路由的声明顺序，所以可能会出现<code>{1:&#39;b.js&#39;, 2:&#39;a.js&#39;}</code>这种编译状况。</strong></p><p>但同样的代码，为什么本地开发环境没出现这种状况？<br>同样都设置了<code>chunkName</code>， 但通过编译后的文件发现， 开发环境的manifest是{chunkName:’xxx.js’} 这种形式，规避了数字作为key乱序的问题。</p><p>但测试和生产环境并不是这种表现，而是数字作为key，不符合预期。<br>进入内部的webpack配置查看发现，在开发环境配置了<code>NamedChunksPlugin</code>，生成了稳定的chunkId, manifest能通过唯一的来一一对应。</p><p>资料：<a href="https://segmentfault.com/q/1010000011524513/a-1020000012187471" target="_blank" rel="noopener">https://segmentfault.com/q/1010000011524513/a-1020000012187471</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题一：&quot;&gt;&lt;a href=&quot;#问题一：&quot; class=&quot;headerlink&quot; title=&quot;问题一：&quot;&gt;&lt;/a&gt;问题一：&lt;/h3&gt;&lt;p&gt;用公司前端架构组给的tools工具时，在test环境下容易出现模块加载错误的问题。&lt;br&gt;观察发现，index.html， main.[hash].js 等资源文件缓存304， 各个路由页面引用的还是之前的hash资源，导致Jenkins新构建的资源没有被使用，而原来的资源已经被替换，找不到文件，所以出错。&lt;/p&gt;
&lt;p&gt;将index.html 不缓存，每次 200 请求最新的，从而刷新各个资源文件。&lt;/p&gt;
&lt;h3 id=&quot;问题二：&quot;&gt;&lt;a href=&quot;#问题二：&quot; class=&quot;headerlink&quot; title=&quot;问题二：&quot;&gt;&lt;/a&gt;问题二：&lt;/h3&gt;&lt;p&gt;现象同样是加载失败。&lt;br&gt;区别1： 只有部分页面加载失败&lt;br&gt;区别2： 手动刷新，有时候页面又是好的，但另一个页面出问题。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>npm的一次问题</title>
    <link href="http://yoursite.com/2018/03/03/npm%E7%9A%84%E4%B8%80%E6%AC%A1%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/03/03/npm的一次问题/</id>
    <published>2018-03-03T08:15:52.000Z</published>
    <updated>2018-03-24T13:41:38.822Z</updated>
    
    <content type="html"><![CDATA[<p>环境： win<br>用<code>npm install npm -g</code> 升级npm后， npm失效，任意指令报错 <code>ERR: cannot find module &#39;xxx&#39;</code>， 但 node指令和cnpm都正常。<br>重新安装node，仍然有问题。</p><p>解决方法：<br>删除 <code>AppData/Roaming/</code> 文件夹下的 npm 和 npm-cache文件夹后解决问题，<br>npm npm-cache 是 全局npm包的安装，所以需要重新安装全局的npm包，如 cnpm, gulp, webpack等</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;环境： win&lt;br&gt;用&lt;code&gt;npm install npm -g&lt;/code&gt; 升级npm后， npm失效，任意指令报错 &lt;code&gt;ERR: cannot find module &amp;#39;xxx&amp;#39;&lt;/code&gt;， 但 node指令和cnpm都正常。&lt;br&gt;重新安装node，仍然有问题。&lt;/p&gt;
&lt;p&gt;解决方法：&lt;br&gt;删除 &lt;code&gt;AppData/Roaming/&lt;/code&gt; 文件夹下的 npm 和 npm-cache文件夹后解决问题，&lt;br&gt;npm npm-cache 是 全局npm包的安装，所以需要重新安装全局的npm包，如 cnpm, gulp, webpack等&lt;/p&gt;
    
    </summary>
    
    
      <category term="npm" scheme="http://yoursite.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>离线缓存</title>
    <link href="http://yoursite.com/2018/02/25/%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2018/02/25/离线缓存/</id>
    <published>2018-02-25T13:31:14.000Z</published>
    <updated>2019-05-04T08:05:52.564Z</updated>
    
    <content type="html"><![CDATA[<p>当前有两种离线缓存方式，一种是H5离线缓存，基于manifest,一种是基于 Service Worker。</p><h3 id="manifest"><a href="#manifest" class="headerlink" title="manifest"></a>manifest</h3><p>其实manifest是一个简单的文本文件，它的扩展名是任意的，定义需要缓存的文件、资源，mime-type 为 text/cache-manifest 。<br>如： <code>&lt;html lang=&quot;en&quot; manifest=&quot;index.manifest&quot;&gt;</code></p><p>优点：</p><ul><li>离线浏览，无网情况下也能正常访问</li><li>更快的加载速度，缓存在本地访问速度自然更快</li><li>减轻服务请求压力，文件缓存后不需要再次请求，只需要请求需要更新的文件</li></ul><hr><p>manifest 文件可分为三个部分：</p><ul><li>CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存</li><li>NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存</li><li>FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）</li></ul><hr><a id="more"></a><p>有三种方式更新manifest缓存：</p><ul><li>用户清空浏览器缓存</li><li>manifest文件被修改，哪怕是注释（所以可以通过修改注释来更新文件）</li><li>由程序来更新</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.applicationCache.addEventListener(&apos;updateready&apos;, function(e) &#123;</span><br><span class="line">  if (window.applicationCache.status == window.applicationCache.UPDATEREADY) &#123;</span><br><span class="line">    // Browser downloaded a new app cache.</span><br><span class="line">    // Swap it in and reload the page to get the new hotness.</span><br><span class="line">    window.applicationCache.swapCache();</span><br><span class="line">      window.location.reload();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // Manifest didn’t changed. Nothing new to server.</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure><hr><div class="tip"><br>1. 站点离线存储的容量限制是5M<br>2. 如果manifest文件，或者内部列举的某一个文件不能正常下载，整个更新过程将视为失败，浏览器继续全部使用老的缓存<br>3. 引用manifest的html必须与manifest文件同源，在同一个域下<br>4. 在manifest中使用的相对路径，相对参照物为manifest文件<br>5. CACHE MANIFEST字符串应在第一行，且必不可少<br>6. 系统会自动缓存引用清单文件的 HTML 文件<br>7. manifest文件中CACHE则与NETWORK，FALLBACK的位置顺序没有关系，如果是隐式声明需要在最前面<br>8. FALLBACK中的资源必须和manifest文件同源<br>9. 当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。<br>10. 站点中的其他页面即使没有设置manifest属性，请求的资源如果在缓存中也从缓存中访问<br>11. 当manifest文件发生改变时，资源请求本身也会触发更新<br></div><h3 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h3><p>Service worker运行在worker上下文，因此它不能访问DOM。相对于驱动应用的主JavaScript线程，它运行在其他线程中，类似与 web worker, 所以不会造成阻塞。它设计为完全异步，同步API（如XHR和localStorage）不能在service worker中使用。</p><p>Service Worker 工作流程： register -&gt; install -&gt; activated ，可监听 install activated 过程事件，fetch message 操作，可实现请求劫持、代理、转发、伪造，消息推送，离线缓存。<br>依赖于HTTPS， 基于Promise，需要缓存Cache API, navigator.applicationCache.</p><p>使用场景：</p><ul><li>后台数据同步</li><li>响应来自其它源的资源请求</li><li>集中接收计算成本高的数据更新，比如地理位置和陀螺仪信息，这样多个页面就可以利用同一组数据</li><li>在客户端进行CoffeeScript，LESS，CJS/AMD等模块编译和依赖管理（用于开发目的）</li><li>后台服务钩子</li><li>自定义模板用于特定URL模式</li><li>性能增强，比如预取用户可能需要的资源，比如相册中的后面数张图片</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当前有两种离线缓存方式，一种是H5离线缓存，基于manifest,一种是基于 Service Worker。&lt;/p&gt;
&lt;h3 id=&quot;manifest&quot;&gt;&lt;a href=&quot;#manifest&quot; class=&quot;headerlink&quot; title=&quot;manifest&quot;&gt;&lt;/a&gt;manifest&lt;/h3&gt;&lt;p&gt;其实manifest是一个简单的文本文件，它的扩展名是任意的，定义需要缓存的文件、资源，mime-type 为 text/cache-manifest 。&lt;br&gt;如： &lt;code&gt;&amp;lt;html lang=&amp;quot;en&amp;quot; manifest=&amp;quot;index.manifest&amp;quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;离线浏览，无网情况下也能正常访问&lt;/li&gt;
&lt;li&gt;更快的加载速度，缓存在本地访问速度自然更快&lt;/li&gt;
&lt;li&gt;减轻服务请求压力，文件缓存后不需要再次请求，只需要请求需要更新的文件&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;manifest 文件可分为三个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存&lt;/li&gt;
&lt;li&gt;NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存&lt;/li&gt;
&lt;li&gt;FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>http缓存</title>
    <link href="http://yoursite.com/2018/02/25/http%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2018/02/25/http缓存/</id>
    <published>2018-02-25T12:27:32.000Z</published>
    <updated>2018-03-24T13:40:43.193Z</updated>
    
    <content type="html"><![CDATA[<h3 id="http的缓存策略"><a href="#http的缓存策略" class="headerlink" title="http的缓存策略"></a>http的缓存策略</h3><p>关键字段 Cache-Control: max-age, expires, ETag, Last-Modified</p><h4 id="优先级顺序"><a href="#优先级顺序" class="headerlink" title="优先级顺序"></a>优先级顺序</h4><ol><li><code>Cache-Control</code> : 强缓存，<code>no-cache</code>是不缓存， <code>max-age</code> 设置缓存生效时间，单位为秒(s)</li><li><code>Expires</code> : 缓存过期时间，单位是具体时间的 Date</li><li><code>ETag</code> : 资源内容的 hash 值， 如果资源没变化， <code>If-None-Match</code> 为false， 返回 304</li><li><code>Last-Modified</code> : 资源的最后修改日期，单位为秒(s)， <code>If-Modified-Since</code> 包含上一次的时间，如果一致，返回304</li></ol><h4 id="ETag-Last-Modefied"><a href="#ETag-Last-Modefied" class="headerlink" title="ETag Last-Modefied"></a>ETag Last-Modefied</h4><p>ETag是对Last-Modefied的功能补充，优先级更高。</p><ul><li>ETag是针对内容的 hash 变化，而 <code>Last-Modefied</code> 单位是秒， 对于 1s 内的多次改变无法感知。</li><li>周期性改变的资源，<code>Last-Modefied</code> 时间会改变，而内容不变的话，ETag 也不变，ETag对于缓存更有利。</li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;http的缓存策略&quot;&gt;&lt;a href=&quot;#http的缓存策略&quot; class=&quot;headerlink&quot; title=&quot;http的缓存策略&quot;&gt;&lt;/a&gt;http的缓存策略&lt;/h3&gt;&lt;p&gt;关键字段 Cache-Control: max-age, expires, ETag, Last-Modified&lt;/p&gt;
&lt;h4 id=&quot;优先级顺序&quot;&gt;&lt;a href=&quot;#优先级顺序&quot; class=&quot;headerlink&quot; title=&quot;优先级顺序&quot;&gt;&lt;/a&gt;优先级顺序&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Cache-Control&lt;/code&gt; : 强缓存，&lt;code&gt;no-cache&lt;/code&gt;是不缓存， &lt;code&gt;max-age&lt;/code&gt; 设置缓存生效时间，单位为秒(s)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Expires&lt;/code&gt; : 缓存过期时间，单位是具体时间的 Date&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ETag&lt;/code&gt; : 资源内容的 hash 值， 如果资源没变化， &lt;code&gt;If-None-Match&lt;/code&gt; 为false， 返回 304&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Last-Modified&lt;/code&gt; : 资源的最后修改日期，单位为秒(s)， &lt;code&gt;If-Modified-Since&lt;/code&gt; 包含上一次的时间，如果一致，返回304&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;ETag-Last-Modefied&quot;&gt;&lt;a href=&quot;#ETag-Last-Modefied&quot; class=&quot;headerlink&quot; title=&quot;ETag Last-Modefied&quot;&gt;&lt;/a&gt;ETag Last-Modefied&lt;/h4&gt;&lt;p&gt;ETag是对Last-Modefied的功能补充，优先级更高。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ETag是针对内容的 hash 变化，而 &lt;code&gt;Last-Modefied&lt;/code&gt; 单位是秒， 对于 1s 内的多次改变无法感知。&lt;/li&gt;
&lt;li&gt;周期性改变的资源，&lt;code&gt;Last-Modefied&lt;/code&gt; 时间会改变，而内容不变的话，ETag 也不变，ETag对于缓存更有利。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>grunt_gulp</title>
    <link href="http://yoursite.com/2018/02/13/grunt-gulp/"/>
    <id>http://yoursite.com/2018/02/13/grunt-gulp/</id>
    <published>2018-02-13T13:29:31.000Z</published>
    <updated>2018-03-24T13:40:14.881Z</updated>
    
    <content type="html"><![CDATA[<p>###<br><code>grunt</code> 与 <code>gulp</code> 其实是很像的。</p><ul><li>loadNpmTasks(‘grunt-<em>‘) === requier(‘gulp-</em>‘)    //载入处理插件</li><li>registerTask === task   //创建任务</li><li>grunt [taskName]  ==== gulp [taskName]   //执行某个任务</li></ul><p>区别：</p><ul><li>对于要处理的文件较多较大时， gulp 基于流 速度会快不少</li><li>gulp简单的<code>.src-&gt;.pipe-&gt;.dest</code>,任务流程很清晰， 而grunt是基于配置，然后创建任务，配置与任务分离，如果配置较多时，可读性就不如gulp task了</li></ul><p>为什么gulp会比grunt更受欢迎? </p><ul><li>gulp 速度更快，这个可能是更多的情况，毕竟项目一般引入的外部资源都不少，如果一点改动就执行好几秒，体验是很差的，但可以解决，对dev开发环境进行配置，资源文件单独处理，生产环境再打包压缩。</li><li>gulp 主要API就5个 <code>.src</code> <code>.dest</code> <code>.pipe</code> <code>.task</code> <code>.watch</code>， 再配合官网的指南，上手难度低，而且任务可读性会更好</li></ul><p>两者一对比， gulp 的学习成本低、易上手的优势就更大了。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###&lt;br&gt;&lt;code&gt;grunt&lt;/code&gt; 与 &lt;code&gt;gulp&lt;/code&gt; 其实是很像的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;loadNpmTasks(‘grunt-&lt;em&gt;‘) === requier(‘gulp-&lt;/em&gt;‘)    //载入处理插件&lt;/li&gt;
&lt;li&gt;registerTask === task   //创建任务&lt;/li&gt;
&lt;li&gt;grunt [taskName]  ==== gulp [taskName]   //执行某个任务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于要处理的文件较多较大时， gulp 基于流 速度会快不少&lt;/li&gt;
&lt;li&gt;gulp简单的&lt;code&gt;.src-&amp;gt;.pipe-&amp;gt;.dest&lt;/code&gt;,任务流程很清晰， 而grunt是基于配置，然后创建任务，配置与任务分离，如果配置较多时，可读性就不如gulp task了&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么gulp会比grunt更受欢迎? &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gulp 速度更快，这个可能是更多的情况，毕竟项目一般引入的外部资源都不少，如果一点改动就执行好几秒，体验是很差的，但可以解决，对dev开发环境进行配置，资源文件单独处理，生产环境再打包压缩。&lt;/li&gt;
&lt;li&gt;gulp 主要API就5个 &lt;code&gt;.src&lt;/code&gt; &lt;code&gt;.dest&lt;/code&gt; &lt;code&gt;.pipe&lt;/code&gt; &lt;code&gt;.task&lt;/code&gt; &lt;code&gt;.watch&lt;/code&gt;， 再配合官网的指南，上手难度低，而且任务可读性会更好&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两者一对比， gulp 的学习成本低、易上手的优势就更大了。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Angular1小结</title>
    <link href="http://yoursite.com/2018/02/13/Angular1%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2018/02/13/Angular1小结/</id>
    <published>2018-02-13T13:25:46.000Z</published>
    <updated>2018-03-24T13:38:56.994Z</updated>
    
    <content type="html"><![CDATA[<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>定义过滤器，返回一个filter function，在指令模板下可以进行一些筛选操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">angular.module(&apos;filterModule&apos;)</span><br><span class="line">    .filter(&apos;fileSize&apos;, function () &#123;</span><br><span class="line">      return function (value) &#123;</span><br><span class="line">        var bytes = parseInt(value, 10);</span><br><span class="line">        var byteLabel = bytes &gt; 1 ? &apos;Bytes&apos; : &apos;Byte&apos;;</span><br><span class="line">        var sizes = [byteLabel, &apos;KB&apos;, &apos;MB&apos;, &apos;GB&apos;, &apos;TB&apos;];</span><br><span class="line">        var i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));</span><br><span class="line">        return Math.round(bytes / Math.pow(1024, i), 2) + &apos; &apos; + sizes[i];</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p><hr><h3 id="factory-service"><a href="#factory-service" class="headerlink" title="factory service"></a>factory service</h3><p>factory service 都可以提供 xhr 服务，功用类似。<br>区别在于factory是返回一个实例对象， 而service是将服务绑定在this上的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">angular.module(&apos;httpModule&apos;)</span><br><span class="line">    .factory(&apos;api&apos;, function($http, $q)&#123;</span><br><span class="line">        var api = &#123;&#125;;</span><br><span class="line">        api.func1 = function()&#123;&#125;</span><br><span class="line">        api.func2 = function()&#123;&#125;</span><br><span class="line"></span><br><span class="line">        return api;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">angular.module(&apos;httpModule&apos;)</span><br><span class="line">    .service(&apos;api&apos;, function($http, $q)&#123;</span><br><span class="line">        var self = this;</span><br><span class="line">        self.func1 = function()&#123;&#125;</span><br><span class="line">        self.func2 = function()&#123;&#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p><hr><a id="more"></a><h3 id="directive"><a href="#directive" class="headerlink" title="directive"></a>directive</h3><p>指令一般用于html和dom的操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">angular.module(&apos;tabDirectives&apos;, [])</span><br><span class="line">  .directive(&apos;showTab&apos;,</span><br><span class="line">    function () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">      //  restrict: &apos;ACE&apos;,</span><br><span class="line">      //  template: &apos;&apos;,  </span><br><span class="line">      //  templateUrl: &apos;&apos;,</span><br><span class="line">        link: function (scope, element) &#123;</span><br><span class="line">          element.click(function(e) &#123;</span><br><span class="line">            e.preventDefault();</span><br><span class="line">            $(element).tab(&apos;show&apos;);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure></p><h4 id="指令中scope"><a href="#指令中scope" class="headerlink" title="指令中scope"></a>指令中scope</h4><ul><li>scope=false， 默认指令共享父的scope，两者改变数据，双向更改。</li><li>scope=true，指令初始化时继承父scope的数据，指令中scope改变之前，仍然将继承父scope的数据，但当指令中数据改变后，scope将是孤岛scope，与父scope地址分离。</li><li><p>scope={}，自定义scope，初始化一个scope对象，与父scope分离，提供了3种属性初始化方式。</p><ul><li>@ ：单项prop设置，将父scope传递到指令中</li><li>= ：与父scope双向绑定</li><li>&amp; ：指向父scope中的function</li></ul><hr></li></ul><h3 id="ngRoute"><a href="#ngRoute" class="headerlink" title="ngRoute"></a>ngRoute</h3><p>$routeProvider提供ngRoute服务，<code>.when</code>进行url匹配，指定模板url和controller，otherwise是前面没匹配到最后执行的， 类似switch的default，resolve是在切换前进行执行，data用于参数传递。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">angular.module(&apos;app&apos;, [&apos;ngRoute&apos;])</span><br><span class="line">    .config(function($routeProvider, $locationProvider) &#123;</span><br><span class="line"></span><br><span class="line">    $locationProvider.html5Mode(true);  //开启html5模式</span><br><span class="line">    //路由匹配</span><br><span class="line">    $routeProvider</span><br><span class="line">    .when(&apos;/page1&apos;, &#123;  </span><br><span class="line">        templateUrl: &apos;page1.tpl.html&apos;,  </span><br><span class="line">        controller: &apos;page1Controller&apos;  </span><br><span class="line">    &#125;)  </span><br><span class="line">    .when(&apos;/page/:id, &#123;</span><br><span class="line">        templateUrl: &apos;page.tpl.html&apos;,  </span><br><span class="line">        controller: &apos;pageController&apos; </span><br><span class="line">    &#125;)</span><br><span class="line">    .otherwise(&#123;</span><br><span class="line">      templateUrl: &apos;app.tpl.html&apos;,</span><br><span class="line">      controller: &apos;appController&apos;,</span><br><span class="line">      resolve: &#123;</span><br><span class="line">        myVar: function(authService) &#123;</span><br><span class="line">          return authService.init();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        authorizedRoles: [&apos;admin&apos;, &apos;creator&apos;, &apos;manager&apos;, &apos;guest&apos;]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    .run( function ($rootScope, $window, $location, $log) &#123;  </span><br><span class="line">        // 监听路由更改事件</span><br><span class="line">        $rootScope.$on(&apos;$routeChangeStart&apos;, function (event, current, previous) &#123;</span><br><span class="line">        if(current.$$route &amp;&amp; current.$$route.data) &#123;</span><br><span class="line">            var authorizedRoles = current.$$route.data.authorizedRoles;</span><br><span class="line">            $rootScope.notAuthorized = !authService.isAuthorized(authorizedRoles);</span><br><span class="line">        &#125;</span><br><span class="line">      );  </span><br><span class="line">    </span><br><span class="line">        $rootScope.$on(&apos;$routeChangeSuccess&apos;, function() &#123; &#125;); </span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p><hr><h3 id="digest-apply-scope-rootScope"><a href="#digest-apply-scope-rootScope" class="headerlink" title="$digest $apply $scope $rootScope"></a>$digest $apply $scope $rootScope</h3><p>$rootScope是所有$scope的上级，相当于全局的$scope<br>$digest更新自身scope和子scope， $apply从$rootScope更新</p><h3 id="event"><a href="#event" class="headerlink" title="event"></a>event</h3><p>$emit 向上<br>$broadcast 向下<br>$scope.on() 接收</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li>减少 $watch</li><li>ng-if 会卸载dom和$watch， 比ng-show效果好点</li><li>减少不必要的$digest $apply</li><li>ng-repeat track by</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;filter&quot;&gt;&lt;a href=&quot;#filter&quot; class=&quot;headerlink&quot; title=&quot;filter&quot;&gt;&lt;/a&gt;filter&lt;/h3&gt;&lt;p&gt;定义过滤器，返回一个filter function，在指令模板下可以进行一些筛选操作。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;angular.module(&amp;apos;filterModule&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .filter(&amp;apos;fileSize&amp;apos;, function () &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      return function (value) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var bytes = parseInt(value, 10);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var byteLabel = bytes &amp;gt; 1 ? &amp;apos;Bytes&amp;apos; : &amp;apos;Byte&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var sizes = [byteLabel, &amp;apos;KB&amp;apos;, &amp;apos;MB&amp;apos;, &amp;apos;GB&amp;apos;, &amp;apos;TB&amp;apos;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return Math.round(bytes / Math.pow(1024, i), 2) + &amp;apos; &amp;apos; + sizes[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;factory-service&quot;&gt;&lt;a href=&quot;#factory-service&quot; class=&quot;headerlink&quot; title=&quot;factory service&quot;&gt;&lt;/a&gt;factory service&lt;/h3&gt;&lt;p&gt;factory service 都可以提供 xhr 服务，功用类似。&lt;br&gt;区别在于factory是返回一个实例对象， 而service是将服务绑定在this上的。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;angular.module(&amp;apos;httpModule&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .factory(&amp;apos;api&amp;apos;, function($http, $q)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var api = &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        api.func1 = function()&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        api.func2 = function()&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return api;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;angular.module(&amp;apos;httpModule&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .service(&amp;apos;api&amp;apos;, function($http, $q)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var self = this;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.func1 = function()&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.func2 = function()&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="angular.js" scheme="http://yoursite.com/tags/angular-js/"/>
    
  </entry>
  
  <entry>
    <title>canvas:path2D,离屏canvas</title>
    <link href="http://yoursite.com/2018/01/14/canvas-path2D-%E7%A6%BB%E5%B1%8Fcanvas/"/>
    <id>http://yoursite.com/2018/01/14/canvas-path2D-离屏canvas/</id>
    <published>2018-01-14T07:57:02.000Z</published>
    <updated>2018-03-24T13:39:24.088Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Path2D"><a href="#Path2D" class="headerlink" title="Path2D"></a>Path2D</h2><h4 id="Path2D-概念"><a href="#Path2D-概念" class="headerlink" title="Path2D 概念"></a>Path2D 概念</h4><p>Canvas 2D API 的接口 Path2D 用来声明路径，此路径稍后会被CanvasRenderingContext2D 对象使用。CanvasRenderingContext2D 接口的 路径方法 也存在于 Path2D 这个接口中，允许你在 canvas 中根据需要创建可以保留并重用的路径。<br><strong>当前IE safari 还不支持</strong></p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>一句话， <strong>缓存图形path</strong></p><h4 id="作用场景"><a href="#作用场景" class="headerlink" title="作用场景"></a>作用场景</h4><ul><li>假如随机生成的图形，常见的方法，保存图形参数</li><li><code>clearRect</code> 清空canvas后，需要回显刚才的图形</li><li><code>isPointInPath</code> 判断事件path区域</li></ul><a id="more"></a><p>常见使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">var tmpPathArr = [];</span><br><span class="line">for ( var i=0; i&lt;10; i++ )&#123;</span><br><span class="line">    var cx = Math.floor( Math.random()*300 ),</span><br><span class="line">        cy = Math.floor( Math.random()*300 ),</span><br><span class="line">        r = Math.floor( Math.random() * 255 ),</span><br><span class="line">        g = Math.floor( Math.random() * 255 ),</span><br><span class="line">        b = Math.floor( Math.random() * 255 ) ; </span><br><span class="line"></span><br><span class="line">    ctx.beginPath();  </span><br><span class="line">    ctx.fillStyle = &apos;rgb(&apos;+r+&apos;,&apos;+g+&apos;,&apos;+b+&apos;)&apos;;</span><br><span class="line">    ctx.arc(cx, cy, 30, 0, 2*Math.PI);</span><br><span class="line">    ctx.fill();</span><br><span class="line">    //保存图形的参数</span><br><span class="line">    tmpPathArr.push( &#123;cx:cx,cy:cy,rgb:ctx.fillStyle&#125; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//清空后回显</span><br><span class="line">ctx.clearRect(0,0, canvas.width, canvas.height);</span><br><span class="line">tmpPathArr.map(function(v)&#123;</span><br><span class="line">    ctx.beginPath();  </span><br><span class="line">    ctx.fillStyle = v.rgb;</span><br><span class="line">    ctx.arc(v.cx, v.cy, 30, 0, 2*Math.PI);</span><br><span class="line">    ctx.fill();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//isPointInPath</span><br><span class="line">canvas.onmousedown = function(ev)&#123;  </span><br><span class="line">    var e = ev||event;  </span><br><span class="line">    var x = e.clientX;  </span><br><span class="line">    var y = e.clientY;  </span><br><span class="line">    tmpPathArr.map(function(v)&#123;</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.arc(v.cx, v.cy, 30, 0, 2*Math.PI);</span><br><span class="line">        if ( ctx.isPointInPath(x,y) )&#123;  </span><br><span class="line">            // 判断区域</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>使用Path2D<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">var tmpPathArr = [];</span><br><span class="line">for ( var i=0; i&lt;10; i++ )&#123;</span><br><span class="line">    var cx = Math.floor( Math.random()*300 ),</span><br><span class="line">        cy = Math.floor( Math.random()*300 ),</span><br><span class="line">        r = Math.floor( Math.random() * 255 ),</span><br><span class="line">        g = Math.floor( Math.random() * 255 ),</span><br><span class="line">        b = Math.floor( Math.random() * 255 ) ; </span><br><span class="line"></span><br><span class="line">    ctx.beginPath();  </span><br><span class="line">    ctx.fillStyle = &apos;rgb(&apos;+r+&apos;,&apos;+g+&apos;,&apos;+b+&apos;)&apos;;</span><br><span class="line"></span><br><span class="line">    //利用path2直接保存图形，然后绘制图形</span><br><span class="line">    var path2D = new Path2D();        </span><br><span class="line">    path2D.arc(cx, cy, 30, 0, 2*Math.PI);</span><br><span class="line">    path2D.rgb = ctx.fillStyle;</span><br><span class="line">    ctx.fill( path2D );</span><br><span class="line">    //保存图形的参数</span><br><span class="line">    tmpPathArr.push( path2D );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//清空后回显</span><br><span class="line">ctx.clearRect(0,0, canvas.width, canvas.height);</span><br><span class="line">tmpPathArr.map(function(v)&#123;</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.fillStyle = v.rgb;</span><br><span class="line">    ctx.fill( v );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//isPointInPath</span><br><span class="line">canvas.onmousedown = function(ev)&#123;  </span><br><span class="line">    var e = ev||event;  </span><br><span class="line">    var x = e.clientX;  </span><br><span class="line">    var y = e.clientY;  </span><br><span class="line">    tmpPathArr.map(function(v)&#123;</span><br><span class="line">        if ( ctx.isPointInPath(v, x,y) )&#123;</span><br><span class="line">            //判断区域</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="Path2优点"><a href="#Path2优点" class="headerlink" title="Path2优点"></a>Path2优点</h4><ul><li>直接保存图形，不用关心图形参数，快速绘制</li><li>判断事件区域时，简单直接的使用 <code>ctx.isPointInPath(path2D,x,y)</code> ，不用绘制缓存的图形，取得上下文context后再判断</li><li>如果是多path的复杂图形，使用path2D优势将更明显，不需要保存图形复杂的绘制参数，方便开发和使用</li></ul><h2 id="离屏canvas"><a href="#离屏canvas" class="headerlink" title="离屏canvas"></a>离屏canvas</h2><h4 id="离屏canvas-1"><a href="#离屏canvas-1" class="headerlink" title="离屏canvas"></a>离屏canvas</h4><ul><li>创建的一个不显示的canvas，方便保存画布的静态场景</li><li>减少图形的绘制，优化性能</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//创建离屏canvas</span><br><span class="line">var  offCanvas = document.createElement(&quot;canvas&quot;);  </span><br><span class="line">offCanvas.width=400;  </span><br><span class="line">offCanvas.height=400;  </span><br><span class="line">var offContext = offCanvas.getContext(&quot;2d&quot;);  </span><br><span class="line"></span><br><span class="line">for ( var i=0; i&lt;10; i++ )&#123;</span><br><span class="line">    var cx = Math.floor( Math.random()*300 ),</span><br><span class="line">        cy = Math.floor( Math.random()*300 ),</span><br><span class="line">        r = Math.floor( Math.random() * 255 ),</span><br><span class="line">        g = Math.floor( Math.random() * 255 ),</span><br><span class="line">        b = Math.floor( Math.random() * 255 ) ; </span><br><span class="line">    //在离屏canvas上绘制场景，此时图形在离屏canvas上，并不显示</span><br><span class="line">    offContext.beginPath();  </span><br><span class="line">    offContext.fillStyle = &apos;rgb(&apos;+r+&apos;,&apos;+g+&apos;,&apos;+b+&apos;)&apos;;</span><br><span class="line">    offContext.arc(cx, cy, 30, 0, 2*Math.PI);</span><br><span class="line">    offContext.fill();</span><br><span class="line">&#125;</span><br><span class="line">//drawImage直接绘制整个离屏canvas的图形</span><br><span class="line">ctx.drawImage(offCanvas,0,0);</span><br></pre></td></tr></table></figure><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>静态的背景及不变的图形，每次重绘、回显时，可以直接绘制背景及图形，优化性能</li><li>重复或相似的图形，此时，可以将离屏canvas类比Sprite，保存各种图形的不同状态，利用<code>drawImage</code> 定位图形位置和区域大小，绘制要需要的部分图形</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Path2D&quot;&gt;&lt;a href=&quot;#Path2D&quot; class=&quot;headerlink&quot; title=&quot;Path2D&quot;&gt;&lt;/a&gt;Path2D&lt;/h2&gt;&lt;h4 id=&quot;Path2D-概念&quot;&gt;&lt;a href=&quot;#Path2D-概念&quot; class=&quot;headerlink&quot; title=&quot;Path2D 概念&quot;&gt;&lt;/a&gt;Path2D 概念&lt;/h4&gt;&lt;p&gt;Canvas 2D API 的接口 Path2D 用来声明路径，此路径稍后会被CanvasRenderingContext2D 对象使用。CanvasRenderingContext2D 接口的 路径方法 也存在于 Path2D 这个接口中，允许你在 canvas 中根据需要创建可以保留并重用的路径。&lt;br&gt;&lt;strong&gt;当前IE safari 还不支持&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;作用&quot;&gt;&lt;a href=&quot;#作用&quot; class=&quot;headerlink&quot; title=&quot;作用&quot;&gt;&lt;/a&gt;作用&lt;/h4&gt;&lt;p&gt;一句话， &lt;strong&gt;缓存图形path&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;作用场景&quot;&gt;&lt;a href=&quot;#作用场景&quot; class=&quot;headerlink&quot; title=&quot;作用场景&quot;&gt;&lt;/a&gt;作用场景&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;假如随机生成的图形，常见的方法，保存图形参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clearRect&lt;/code&gt; 清空canvas后，需要回显刚才的图形&lt;/li&gt;
&lt;li&gt;&lt;code&gt;isPointInPath&lt;/code&gt; 判断事件path区域&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="canvas" scheme="http://yoursite.com/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>svgvg_bezier</title>
    <link href="http://yoursite.com/2018/01/01/svgvg-bezier/"/>
    <id>http://yoursite.com/2018/01/01/svgvg-bezier/</id>
    <published>2018-01-01T13:05:50.000Z</published>
    <updated>2018-03-24T13:41:58.835Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一种连接两个点的贝塞尔曲线"><a href="#一种连接两个点的贝塞尔曲线" class="headerlink" title="一种连接两个点的贝塞尔曲线"></a>一种连接两个点的贝塞尔曲线</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function bezier(startPoint, endPoint)&#123;</span><br><span class="line">    var sx = startPoint.x,</span><br><span class="line">        sy = startPoint.y,</span><br><span class="line">        ex = endPoint.x,</span><br><span class="line">        ey = endPoint.y,</span><br><span class="line">        length = Math.sqrt( Math.pow( (sx-ex), 2) + Math.pow( (sy-ey), 2 ) ) ;</span><br><span class="line"></span><br><span class="line">    //可以根据两点的倾斜方向做更加细致的取点，这里只列出其中一种方式</span><br><span class="line"></span><br><span class="line">    if ( Math.abs( sx - ex ) &lt; 5 )&#123;  //两个点的横坐标差值小于5，姑且认为是平行的，这里可以自行设置</span><br><span class="line">        return [startPoint, &#123;x:sx-length, y:sy&#125;, &#123;x:ex+length, y:ey&#125;, endPoint] ;</span><br><span class="line">    &#125;</span><br><span class="line">    else if ( Math.abs( sy - ey ) &lt; 5&gt; )&#123;  //纵坐标相同</span><br><span class="line">        return [startPoint, &#123;x:sx, y:sy-length&#125;, &#123;x:ex, y:ey+length&#125;, endPoint] ;        </span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;  //斜率的情况</span><br><span class="line">        var slope = (ey-sy) / (ex-sx),   //斜率</span><br><span class="line">            dx = Math.sqrt( Math.pow(length,2) / ( 1+ 1/(slope*slope) ) ),  //x坐标变化值</span><br><span class="line">            dy = Math.abs(-1/slope * dx)  ;</span><br><span class="line">        return [startPoint, &#123;x:sx-dx, y:sy-dy&#125;, &#123;x:ex+dx ,y:ey+dy&#125;, endPoint] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var pointArr = bezier(&#123;x:11, y:22&#125;, &#123;x:33, y:44&#125;);</span><br><span class="line">$(&apos;svg #path&apos;).attr(&apos;d&apos;, &apos;M&apos;+pointArr[0].x+&apos; &apos;+pointArr[0].y+&apos; C &apos;+pointArr[1].x+&apos; &apos;+pointArr[1].y+&apos;, &apos;+pointArr[2].x+&apos; &apos;+pointArr[2].y+&apos;, &apos;+pointArr[3].x+&apos; &apos;+pointArr[3].y);</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="svg-path更新问题"><a href="#svg-path更新问题" class="headerlink" title="svg path更新问题"></a>svg path更新问题</h3><p>可能有这种场景， 在插入一段svg path后， 需要更改该path的路径， 于是重新设置path 的 ‘d’ 路径path， 在F12可以看到path更改后，但页面上线条并没有改变。<br>普通的dom插入页面，调用<code>.appendChild()</code>，但svg不算dom，所以插入path，当作dom来更改无效。</p><p>##解决方法##<br><code>.createElementNS</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var path = document.createElementNS(&apos;ttp://www.w3.org/2000/svg&apos;, &apos;path&apos;);</span><br><span class="line">$(path).attr(&#123;//设置属性&#125;).append(//)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一种连接两个点的贝塞尔曲线&quot;&gt;&lt;a href=&quot;#一种连接两个点的贝塞尔曲线&quot; class=&quot;headerlink&quot; title=&quot;一种连接两个点的贝塞尔曲线&quot;&gt;&lt;/a&gt;一种连接两个点的贝塞尔曲线&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function bezier(startPoint, endPoint)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var sx = startPoint.x,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sy = startPoint.y,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ex = endPoint.x,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ey = endPoint.y,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        length = Math.sqrt( Math.pow( (sx-ex), 2) + Math.pow( (sy-ey), 2 ) ) ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //可以根据两点的倾斜方向做更加细致的取点，这里只列出其中一种方式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if ( Math.abs( sx - ex ) &amp;lt; 5 )&amp;#123;  //两个点的横坐标差值小于5，姑且认为是平行的，这里可以自行设置&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return [startPoint, &amp;#123;x:sx-length, y:sy&amp;#125;, &amp;#123;x:ex+length, y:ey&amp;#125;, endPoint] ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    else if ( Math.abs( sy - ey ) &amp;lt; 5&amp;gt; )&amp;#123;  //纵坐标相同&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return [startPoint, &amp;#123;x:sx, y:sy-length&amp;#125;, &amp;#123;x:ex, y:ey+length&amp;#125;, endPoint] ;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    else &amp;#123;  //斜率的情况&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var slope = (ey-sy) / (ex-sx),   //斜率&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            dx = Math.sqrt( Math.pow(length,2) / ( 1+ 1/(slope*slope) ) ),  //x坐标变化值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            dy = Math.abs(-1/slope * dx)  ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return [startPoint, &amp;#123;x:sx-dx, y:sy-dy&amp;#125;, &amp;#123;x:ex+dx ,y:ey+dy&amp;#125;, endPoint] ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var pointArr = bezier(&amp;#123;x:11, y:22&amp;#125;, &amp;#123;x:33, y:44&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$(&amp;apos;svg #path&amp;apos;).attr(&amp;apos;d&amp;apos;, &amp;apos;M&amp;apos;+pointArr[0].x+&amp;apos; &amp;apos;+pointArr[0].y+&amp;apos; C &amp;apos;+pointArr[1].x+&amp;apos; &amp;apos;+pointArr[1].y+&amp;apos;, &amp;apos;+pointArr[2].x+&amp;apos; &amp;apos;+pointArr[2].y+&amp;apos;, &amp;apos;+pointArr[3].x+&amp;apos; &amp;apos;+pointArr[3].y);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
