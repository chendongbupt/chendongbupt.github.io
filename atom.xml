<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CDBlog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-02T13:19:00.476Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>chendong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初次开发hybrid H5的坑及方案</title>
    <link href="http://yoursite.com/2019/03/02/%E5%88%9D%E6%AC%A1%E5%BC%80%E5%8F%91hybrid-H5%E7%9A%84%E5%9D%91%E5%8F%8A%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2019/03/02/初次开发hybrid-H5的坑及方案/</id>
    <published>2019-03-02T11:19:06.000Z</published>
    <updated>2019-03-02T13:19:00.476Z</updated>
    
    <content type="html"><![CDATA[<h4 id="hybrid-h5"><a href="#hybrid-h5" class="headerlink" title="hybrid h5"></a>hybrid h5</h4><p>hybrid 翻译为杂交， hyrid h5 是指将web前端页面嵌入到原生APP( iOS和Android )中的运行的方案。<br>相对于原生开发，web前端的开发发展时间更长、从业人员更多、生态更为繁荣，而且开发效率也更高。<br>但web并不能直接调用原生API，而且运行内存、调度也差与原生，流畅性就显得不足。<br>基于以上原因，协调开发资源，将一些展示性、交互不多的页面让web开发，嵌入原生Webview中运行，就可以大大提高APP开发效率，利用团队开发资源。</p><a id="more"></a><h4 id="h5调用原生方法"><a href="#h5调用原生方法" class="headerlink" title="h5调用原生方法"></a>h5调用原生方法</h4><p>参考 (<a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="noopener">https://github.com/marcuswestin/WebViewJavascriptBridge</a>)</p><ol><li>直接注入调用<br>iOS能访问Webview下全局对象window，所以可以将js方法挂载到window上，然后iOS调用；<br>安卓的话可以注入方法到window上，然后js调用这原生方法。</li><li>协议监听<br>原生API能拦截Webview的网络请求，url根据协议传参，原生解析后执行，将结果挂载到window上。<br>js的url实现方法：<br> 2.1 window.location.href<br> 2.2 利用页面中嵌套的iframe的url(将iframe的长宽都设为很小或者0，取到数据后再移除这个iframe)建议使用②iframe的方式，因为如果我们连续多次修改window.location.href的值，在Native层只能接收到最后一次请求，前面的请求都会被忽略掉。</li><li>引入JsBridge（安卓）和 WebViewJavascriptBridge（iOS）库的方案<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 安卓运行</span><br><span class="line">// 如果WebViewJavascriptBridge已挂载，直接执行，否则，等待WebViewJavascriptBridgeReady时间触发，即原生方法已挂载后执行</span><br><span class="line">if (window.WebViewJavascriptBridge) &#123;</span><br><span class="line">    //do your work here</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    document.addEventListener(</span><br><span class="line">        &apos;WebViewJavascriptBridgeReady&apos;</span><br><span class="line">        , function() &#123;</span><br><span class="line">            //do your work here</span><br><span class="line">        &#125;,</span><br><span class="line">        false</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// iOS运行</span><br><span class="line">function setupWebViewJavascriptBridge(callback) &#123;</span><br><span class="line">if (window.WebViewJavascriptBridge) &#123; return callback(WebViewJavascriptBridge); &#125;</span><br><span class="line">if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback); &#125;</span><br><span class="line">window.WVJBCallbacks = [callback];</span><br><span class="line">var WVJBIframe = document.createElement(&apos;iframe&apos;);</span><br><span class="line">WVJBIframe.style.display = &apos;none&apos;;</span><br><span class="line">WVJBIframe.src = &apos;https://__bridge_loaded__&apos;;</span><br><span class="line">document.documentElement.appendChild(WVJBIframe);</span><br><span class="line">setTimeout(function() &#123; document.documentElement.removeChild(WVJBIframe) &#125;, 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>此次项目，我们直接进行的注入调用。<br>h5中涉及到摄像头拍照的功能，由原生提供，注入到h5中，挂载到window.api上，js则可以直接调用方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.api.camera(params, function()&#123;&#125;)    // 调用原生注入的API，参数不可缺少，传递params参数以及回调函数</span><br></pre></td></tr></table></figure></p><p>html中引入一个固定名称的js文件供安卓注入，比如 android.js， 兼容安卓5，文件不能为空，所以可以声明一个无关紧要的变量或者console。</p><h4 id="兼容遇到的问题"><a href="#兼容遇到的问题" class="headerlink" title="兼容遇到的问题"></a>兼容遇到的问题</h4><ol><li>安卓5下需要对Promise reject进行处理，否在抛错</li><li>es6 spread语法， …obj， 低版本下需要确定obj为Object,如果为’’，会抛错</li><li>iOS调用js方法时，内部不能有Promise，否则会卡死，不执行回调</li><li>用iframe时，iOS会需要src同源，否则会解析失败</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;hybrid-h5&quot;&gt;&lt;a href=&quot;#hybrid-h5&quot; class=&quot;headerlink&quot; title=&quot;hybrid h5&quot;&gt;&lt;/a&gt;hybrid h5&lt;/h4&gt;&lt;p&gt;hybrid 翻译为杂交， hyrid h5 是指将web前端页面嵌入到原生APP( iOS和Android )中的运行的方案。&lt;br&gt;相对于原生开发，web前端的开发发展时间更长、从业人员更多、生态更为繁荣，而且开发效率也更高。&lt;br&gt;但web并不能直接调用原生API，而且运行内存、调度也差与原生，流畅性就显得不足。&lt;br&gt;基于以上原因，协调开发资源，将一些展示性、交互不多的页面让web开发，嵌入原生Webview中运行，就可以大大提高APP开发效率，利用团队开发资源。&lt;/p&gt;
    
    </summary>
    
    
      <category term="H5" scheme="http://yoursite.com/tags/H5/"/>
    
  </entry>
  
  <entry>
    <title>小程序探索</title>
    <link href="http://yoursite.com/2018/12/02/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%A2%E7%B4%A2/"/>
    <id>http://yoursite.com/2018/12/02/小程序探索/</id>
    <published>2018-12-02T08:12:46.000Z</published>
    <updated>2018-12-06T11:56:30.325Z</updated>
    
    <content type="html"><![CDATA[<h3 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h3><ul><li>小程序需要申请账号，主体可以是企业，也可以是个人，里面有小程序的AppID，配置服务地址(比如localhost)</li><li>小程序开发工具，创建工程需要AppID</li><li>开发工具包含代码编辑器+调试器+客户端模拟器+版本管理器，基本做到了一站式开发</li><li>模拟器只有ios和 nexus，再加上原生组件，真机调试不可少</li></ul><h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><p>整个框架像个大杂烩，整体设计并不统一，包含了OO、函数式和面向过程。或许，是为了不同技术栈背景的开发人员都能找到一套适合的开发模式。</p><ul><li>样式层上来看，wxss像个css的子集，缺少了一些特性支持</li><li>模板wxml来看，Mustache语法，类似ng1.js的语法，数据与视图绑定，但数据流不是双向，不是响应式，而是类似React语法的setData，异步单项数据流</li><li>逻辑层js中，Page(Object)类似于Vue1的data设置，逻辑方法写法，同时也包含生命周期函数，可直接访问路由</li><li>wxs和template可直接在wxml中扩展，分别对应了script和模板引擎，可在多个地方引入调用，虽然提供了组件，但开发并不是组件化</li></ul><hr>  <a id="more"></a><h5 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- pages </span><br><span class="line">  - pageA  </span><br><span class="line">    - pageA.js  </span><br><span class="line">    - pageA.wxml  </span><br><span class="line">    - pageA.wxss  </span><br><span class="line">    - pageA.json </span><br><span class="line">  - pageB  </span><br><span class="line">    - pageB.js  </span><br><span class="line">    - pageB.wxml  </span><br><span class="line">    - pageB.wxss  </span><br><span class="line">    - pageB.json</span><br><span class="line">- app.js</span><br><span class="line">- app.wxss</span><br><span class="line">- app.json</span><br></pre></td></tr></table></figure><p>.json 属于配置文件，.wxss 样式文件，.wxml模板，.js(.ts) 逻辑文件</p><p>app.json 是全局配置，pages下的页面配置，只有窗口window部分。</p><table><thead><tr><th>属性</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>pages</td><td style="text-align:center">页面路径入口列表 </td></tr><tr><td>window</td><td style="text-align:center">窗口样式 </td></tr><tr><td>tabBar</td><td style="text-align:center">底部tab </td></tr><tr><td>networkTimeout</td><td style="text-align:center">超时时间 </td></tr><tr><td>debug</td><td style="text-align:center">是否开启debug，默认关闭 </td></tr><tr><td>functionalPages</td><td style="text-align:center">是否启用插件，默认关闭 </td></tr><tr><td>subpackages</td><td style="text-align:center">分包结构配置 </td></tr><tr><td>workers</td><td style="text-align:center">Worker放置目录 </td></tr><tr><td>requiredBackgroundModes</td><td style="text-align:center">需要在后台使用的能力，如音乐播放 </td></tr><tr><td>plugins</td><td style="text-align:center">使用的插件 </td></tr><tr><td>preloadRule</td><td style="text-align:center">分包预下载规则 </td></tr><tr><td>resizable</td><td style="text-align:center">iPad下是否直接屏幕旋转，默认关闭 </td></tr><tr><td>navigateToMiniProgramAppIdList</td><td style="text-align:center">需要跳转的小程序列表 </td></tr><tr><td>usingComponents</td><td style="text-align:center">全局自定义组件配置 </td></tr></tbody></table><p>pages类似于路由，配置页面的入口路径， 例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;pages&quot;:[ </span><br><span class="line">  &quot;pages/pageA/pageA&quot;, </span><br><span class="line">  &quot;pages/pageB/pageB&quot;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><h5 id="逻辑层"><a href="#逻辑层" class="headerlink" title="逻辑层"></a>逻辑层</h5><ul><li>App(Object) 注册App, Page(Object) 注册页面</li><li>data:{}, 初始数据</li><li>Page.route, 得到当前页面路径</li><li>Page.prototype.setData(data, function(){}),更新page中的data</li><li>生命周期函数，onLoad()：页面加载时触发，onShow()：页面显示时触发，onReady()：页面初次渲染完成是触发，onHide()：页面隐藏时触发，onUnload()：页面卸载时触发</li></ul><h5 id="视图层"><a href="#视图层" class="headerlink" title="视图层"></a>视图层</h5><p><strong>wxml</strong> 类似于html，用于页面结构，数据绑定是Mustache语法，类似于ng1.js。</p><p>列表渲染<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 默认下标为index，默认值为item</span><br><span class="line">// 可以用wx:for-index, wx:for-item 自定义</span><br><span class="line">&lt;view wx:for=&quot;&#123;&#123;array&#125;&#125;&quot; wx:for-index=&quot;cusIndex&quot; wx:for-item=&quot;cusItem&quot;&gt;</span><br><span class="line">&#123;&#123;cusItem&#125;&#125;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure></p><p>条件渲染<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;view wx:if=&quot;&#123;&#123;condition&#125;&#125;&quot;&gt;condition is true&lt;/view&gt;</span><br><span class="line">&lt;view wx:elif=&quot;&#123;&#123;condition2&#125;&#125;&quot;&gt;condition2 is true&lt;/view&gt;</span><br><span class="line">&lt;view wx:else&gt;else case&lt;/view&gt;</span><br></pre></td></tr></table></figure></p><p>模板 template，有点类似之前的各种模板引擎，比如handlebars,artTemplate，就是定义一段代码片段，方便在多个地方多次调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个模板，名称为 tmpName</span><br><span class="line">&lt;template name=&quot;tmpName&quot;&gt;</span><br><span class="line">// wxml code</span><br><span class="line">&lt;text&gt;&#123;&#123;a&#125;&#125;&lt;/text&gt;</span><br><span class="line">&lt;text&gt;&#123;&#123;b&#125;&#125;&lt;/text&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">// 使用模板tmpName, 传参 data: &#123; obj:&#123;a:1,b:2&#125; &#125;</span><br><span class="line">&lt;template is=&quot;tmpName&quot; data=&quot;&#123;&#123;...obj&#125;&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>模板有作用域，只能使用data传参的数据，或模板中<wxs>导出的模块数据。</wxs></p><p>事件绑定的写法同组件的属性，以 key、value 的形式。</p><ul><li>key 以bind或catch开头，然后跟上事件的类型，如bindtap、catchtouchstart。自基础库版本 1.5.0 起，在<strong>非原生组件</strong>中，bind和catch后可以紧跟一个冒号，其含义不变，如bind:tap、catch:touchstart。</li><li>value 是一个字符串，需要在对应的 Page 中定义同名的函数。不然当触发事件的时候会报错。</li><li>catch事件绑定可以阻止冒泡事件向上冒泡，capture-catch关键字，将中断捕获阶段和取消冒泡阶段</li><li><strong>原生组件</strong>的事件监听不能使用 bind:eventname 的写法，只支持 bindeventname。原生组件也不支持 catch 和 capture 的事件绑定方式。</li></ul><p>引用包括<code>import</code> <code>include</code>两种方式，又是以前的资源模板用法。<br>import只引入目标中定义的模板，不包含目标文件中import的模板, <import src=""> 引入。<br>include包含目标文件中除了<code>&lt;template&gt;&lt;/template&gt; &lt;wxs /&gt;</code>外的整个代码块，但会解析模板中的<code>&lt;template is=&quot;&quot; /&gt;， &lt;include src=&quot;&quot; /&gt;</code>引入。</import></p><hr><p><strong>wxss</strong> 可以看做”wx css”。相比css，增加了尺寸单位rpx。<br>选择器也有变化，支持class id element和伪类::before,::after， 不支持:hover :nth-child :focus等伪类， 不支持兄弟选择器。</p><hr><p><strong>wsx</strong> 类似于 <code>&lt;script&gt;</code>，是wxml模板中的脚本。示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;wxs module=&quot;m1&quot;&gt;</span><br><span class="line">var msg = &quot;hello world&quot;;</span><br><span class="line"></span><br><span class="line">module.exports.message = msg;</span><br><span class="line">&lt;/wxs&gt;</span><br><span class="line"></span><br><span class="line">&lt;view&gt; &#123;&#123;m1.message&#125;&#125; &lt;/view&gt;</span><br></pre></td></tr></table></figure></p><ul><li>wxs 的运行环境和其他 javascript 代码是隔离的，wxs 中不能调用其他 javascript 文件中定义的函数，也不能调用小程序提供的API。</li><li>wxs 函数不能作为组件的事件回调。</li><li>wxs 如果module和exports和data中的数据重名，将会覆盖</li><li>.wxs文件可以被其他模块require引入</li></ul><hr><p>分包加载是将小程序划分成不同的子包，在构建时打包成不同的分包，用户在使用时按需进行加载，需要在app.json中的subpackages中配置。</p><table><thead><tr><th>字段</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td>root</td><td style="text-align:center">分包根目录 </td></tr><tr><td>name</td><td style="text-align:center">分包别名，分包预下载时可以使用 </td></tr><tr><td>pages</td><td style="text-align:center">分包页面路径 </td></tr><tr><td>independent</td><td style="text-align:center">是否是独立分包 </td></tr></tbody></table><ul><li>tabBar页面必须在主包app内</li><li>分包的根目录必须分开，不能嵌套</li><li>分包之间不能相互import require资源</li></ul><hr><h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><h5 id="视图容器"><a href="#视图容器" class="headerlink" title="视图容器"></a>视图容器</h5><p>提供了外层基本容器View，覆盖容器cover-view，还有常用的轮播图swiper。<br>更注重block容器，没有行内的grid、flex。</p><h5 id="基础内容"><a href="#基础内容" class="headerlink" title="基础内容"></a>基础内容</h5><p>仅有9种icon… text相当于span，属于inline， 还有一个有用的progress进度条。</p><h5 id="表单组件"><a href="#表单组件" class="headerlink" title="表单组件"></a>表单组件</h5><p>包含常用的 button checkbox radio swtich， 还有input textarea， 没有类似table list的组件。<br>picker包含了单选项select功能，还有级联cascader功能，以及时间 timepicker， 日期datepicker，没有时间范围选择功能。</p><h5 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h5><p>navigator跳转，可以满足当前小程序的跳转，也可以跳转到其他小程序</p><h5 id="媒体、地图、画布"><a href="#媒体、地图、画布" class="headerlink" title="媒体、地图、画布"></a>媒体、地图、画布</h5><p>包括 video、image、camera等媒体组件，map、canvas是原生组件。</p><hr><p>小程序的组件库不多，但对于手机端还算足够用。封装了使用频次较高的swiper，picker，但资源型组件，比如icon，内容实在太少。此外，还有<strong>原生组件</strong>的限制，参考<a href="https://developers.weixin.qq.com/miniprogram/dev/component/native-component.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/component/native-component.html</a> 。</p><hr><h4 id="配置ts自动编译"><a href="#配置ts自动编译" class="headerlink" title="配置ts自动编译"></a>配置ts自动编译</h4><ol start="0"><li>前置，需要npm安装typescript</li><li><p>在package.json “scripts”中增加ts文件监听指令 “watch”: “tsc -w”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">&quot;tsc&quot;: &quot;./node_modules/typescript/bin/tsc&quot;,</span><br><span class="line">&quot;compile&quot;: &quot;tsc&quot;,</span><br><span class="line">&quot;watch&quot;: &quot;tsc -w&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>增加编译模式，入口是page/index/index,参数为指令名称watch</p></li><li>然后编译模式，切换到新增的编译模式</li></ol><hr><h5 id="衍生的框架"><a href="#衍生的框架" class="headerlink" title="衍生的框架"></a>衍生的框架</h5><p>wepy <a href="https://github.com/Tencent/wepy" target="_blank" rel="noopener">https://github.com/Tencent/wepy</a></p><p>腾讯出的框架，小程序组件化框架，15k+star</p><p>总结要点:</p><ul><li>类Vue开发风格，组件化 es6 es7， wepy-cli</li><li>小程序细节优化，如请求列队，事件优化等</li></ul><p>缺点：</p><ul><li>脏值检测封装setData，上一个这样做的ng1,性能堪忧</li><li>类Vue，但开发体验不好</li><li>基础组件问题多</li></ul><hr><p>mpvue <a href="https://github.com/Meituan-Dianping/mpvue" target="_blank" rel="noopener">https://github.com/Meituan-Dianping/mpvue</a></p><p>美团开发，基于 Vue.js 的小程序开发框架，从底层支持 Vue.js 语法和构建工具体系， 14.5k+star</p><ul><li>相比wepy, 完整的 Vue.js 开发体验</li><li>彻底的组件化开发能力</li><li>H5 代码转换编译成小程序目标代码的能力</li></ul><p>缺点：<br>有且只能使用单文件组件（.vue 组件）的形式进行支持，详细的不支持列表.</p><ul><li>不支持 纯-HTML</li><li>不支持过滤器</li><li>不支持函数</li><li>暂不支持在组件引用时，在组件上定义 click 等原生事件、v-show（可用 v-if 代替）和 class style 等样式属性</li><li>Slot（scoped 暂时还没做支持）</li><li>动态组件</li><li>异步组件</li><li>inline-template</li><li>X-Templates</li><li>keep-alive</li><li>transition</li><li>class</li><li>style</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;微信小程序&quot;&gt;&lt;a href=&quot;#微信小程序&quot; class=&quot;headerlink&quot; title=&quot;微信小程序&quot;&gt;&lt;/a&gt;微信小程序&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;小程序需要申请账号，主体可以是企业，也可以是个人，里面有小程序的AppID，配置服务地址(比如localhost)&lt;/li&gt;
&lt;li&gt;小程序开发工具，创建工程需要AppID&lt;/li&gt;
&lt;li&gt;开发工具包含代码编辑器+调试器+客户端模拟器+版本管理器，基本做到了一站式开发&lt;/li&gt;
&lt;li&gt;模拟器只有ios和 nexus，再加上原生组件，真机调试不可少&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;框架&quot;&gt;&lt;a href=&quot;#框架&quot; class=&quot;headerlink&quot; title=&quot;框架&quot;&gt;&lt;/a&gt;框架&lt;/h4&gt;&lt;p&gt;整个框架像个大杂烩，整体设计并不统一，包含了OO、函数式和面向过程。或许，是为了不同技术栈背景的开发人员都能找到一套适合的开发模式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;样式层上来看，wxss像个css的子集，缺少了一些特性支持&lt;/li&gt;
&lt;li&gt;模板wxml来看，Mustache语法，类似ng1.js的语法，数据与视图绑定，但数据流不是双向，不是响应式，而是类似React语法的setData，异步单项数据流&lt;/li&gt;
&lt;li&gt;逻辑层js中，Page(Object)类似于Vue1的data设置，逻辑方法写法，同时也包含生命周期函数，可直接访问路由&lt;/li&gt;
&lt;li&gt;wxs和template可直接在wxml中扩展，分别对应了script和模板引擎，可在多个地方引入调用，虽然提供了组件，但开发并不是组件化&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="小程序" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>BizCharts调研</title>
    <link href="http://yoursite.com/2018/11/29/BizCharts%E8%B0%83%E7%A0%94/"/>
    <id>http://yoursite.com/2018/11/29/BizCharts调研/</id>
    <published>2018-11-29T12:13:36.000Z</published>
    <updated>2018-12-06T11:56:37.260Z</updated>
    
    <content type="html"><![CDATA[<h4 id="BizCharts"><a href="#BizCharts" class="headerlink" title="BizCharts"></a>BizCharts</h4><p>官网：<a href="https://bizcharts.net/" target="_blank" rel="noopener">https://bizcharts.net/</a></p><p>简单说下特性:</p><ul><li>基于 G2 封装的 React 图表库，具有 G2、React 的全部优点，可以让用户以组件的形式组合出无数种图表</li><li>集成了大量的统计工具，支持多种坐标系绘制，交互定制，动画定制以及图形定制等</li><li>性能稳定且具有强大的扩展能力和高度自定义能力</li></ul><hr><a id="more"></a><h4 id="和ECharts对比"><a href="#和ECharts对比" class="headerlink" title="和ECharts对比"></a>和ECharts对比</h4><ul><li>ECharts是一个基本库，不依赖其他框架，在React/Vue/Angular中都可以使用。 BizCharts是基于G2的封装，组件的解析依赖于React。</li><li>ECharts是配置型，绝大部分展示交互通过配置options完成; BizCharts是编码型，提供了图表构成的各部分组件，引入组件来绘制图表</li><li>ECharts由百度开源，从2013.6至今，版本从1.0到4.2，包含了24种平面图和10种基于webGL的3D图，实现了多渲染方案(canvas,svg,vml)、跨平台使用，各种功能十分丰富； Bizcharts由ali开源，从2017.12月直接发布3.0版本，至今版本3.2，包含了14种图例，支持canvas,svg渲染方案，仅针对PC端，平台端分离出BizGoblin，功能配置项较ECharts少。</li><li>BizCharts部分功能不完备，例如resize，需要主动由window dispatch resize, 多Y轴需要用Dataset展开，排序没有默认转为数值，需要手动将字符串转为数值。</li><li>性能上，数据量不大的情况下，两者都可以接受。但ECharts有重构底层图形库ZRender,针对移动端优化，所以性能上更好。在图表中自定义一部分dom结构，同样的逻辑，ECharts流畅性能高。</li></ul><h4 id="体验改进"><a href="#体验改进" class="headerlink" title="体验改进"></a>体验改进</h4><p>G2 会将打点监控，默认会将 URL 等信息发送回 AntV 服务器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">url: https://kcart.alipay.com/web/bi.do</span><br><span class="line">param:&#123; </span><br><span class="line">    BIProfile:merge, </span><br><span class="line">    d:[&#123;&quot;bizcharts&quot;:&quot;3.2.5-beta.3&quot;,&quot;pg&quot;:&quot;http://localhost:3000/#/app/2495489/performance/web&quot;,&quot;r&quot;:1541569473246,&quot;g2&quot;:true,&quot;version&quot;:&quot;3.3.3&quot;,&quot;page_type&quot;:&quot;syslog&quot;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br><span class="line">设置track(false)可以关闭。</span><br><span class="line"></span><br><span class="line">BizCharts.track(false);// orimport &#123; track &#125; from &apos;bizcharts&apos;;track(false)常用组件</span><br></pre></td></tr></table></figure></p><hr><h4 id="Chart"><a href="#Chart" class="headerlink" title="Chart"></a>Chart</h4><p>图表最顶级的组件，控制着图表的创建、绘制、销毁等。</p><ul><li>renderer 图表渲染方式，默认为canvas，可设置为svg</li><li>data 图表数据源，JSON对象数组或者DataSet.View对象</li><li>scale 配置图表比例尺, 例如将Y轴设置为从0开始</li><li>padding 默认为’auto’, 比如设置左侧和下面的padding, padding={[‘auto’, ‘auto’, 20, 20]}</li><li>事件支持 <code>onPlotClick</code> 点击， <code>onTooltipChange</code> tooltip变化， <code>onPlotEnter</code>鼠标进入绘图区域等</li></ul><h4 id="Axis"><a href="#Axis" class="headerlink" title="Axis"></a>Axis</h4><p>坐标轴组件，控制图表中坐标轴的样式等。</p><ul><li>name 坐标轴对应数据源的字段key</li><li>label Object对象，{textStyle:{}, formatter(text,item,index){} …}，可设置坐标轴格式及样式等</li></ul><h4 id="Geom"><a href="#Geom" class="headerlink" title="Geom"></a>Geom</h4><p>几何标记对象，决定创建图表的类型。</p><ul><li>type 几何标记类型，有line(线图) interval(柱状图、饼图) area(区域图) edge(树图、关系图等)等</li><li>color 将数据值映射到图形的颜色, 可以是数据字段key,配合Legend组件显示，也可以是[field,[color1,color2]]的颜色映射</li><li>position 位置属性的映射，格式为 “a*b”，a字段对应横轴，b字段对应纵轴</li><li>tooltip 显示图标数据点的提示信息, 格式为<code>[&#39;a*b&#39;, (a,b)=&gt;({name:xx, value:yyy})]</code></li></ul><h4 id="Legend"><a href="#Legend" class="headerlink" title="Legend"></a>Legend</h4><p>图例。</p><ul><li>position 图例位置，默认为 ‘buttom-center’</li><li>layout 图例排列方式，vertical、horizontal</li><li>itemFormatter 图例文本展示</li></ul><h4 id="Tooltip"><a href="#Tooltip" class="headerlink" title="Tooltip"></a>Tooltip</h4><p>tooltip显示信息层</p><ul><li>triggerOn 触发形式，mousemove click none</li><li>crosshairs Object对象，tooltip辅助线样式，如{type:’line’, style:{}}</li></ul><h4 id="Slider"><a href="#Slider" class="headerlink" title="Slider"></a>Slider</h4><p>需要单独安装，<code>npm install bizcharts-plugin-slider</code>，作用与 ECharts <code>dataZoom</code> 类似，可以局部展示图表信息</p><h4 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h4><p>Dataset需要单独安装 <code>npm install @antv/data-set -save</code><br>Dataset Transform 包含很多数据转换，如sort, map, filter等静态处理，也有fold形变处理，还包括树hierarchy, 图diagram处理，可以利用 hierarchy 树形排列数据点，作用类似于包 <code>d3-hierarchy</code> 。</p><p>注意点Tips</p><ul><li>Geom中tooltip字段格式，’a<em>b</em>c’ 符号为 ‘ *</li><li>Geom中color可以为映射的字段名，也可以为颜色，如果颜色和字段名同名，将导致图表刷新切换，不稳定。</li><li>图表resize是监听的window resize事件，所以需要在区域联动变化时手动dispatch事件， window.dispatchEvent(new Event(‘resize’));  (<a href="https://github.com/alibaba/BizCharts/issues/75" target="_blank" rel="noopener">https://github.com/alibaba/BizCharts/issues/75</a>)</li><li>Bizcharts中没有Geom指定Y轴的接口，所以需要用DataView合并使用同一Y轴的数据  (<a href="https://github.com/alibaba/BizCharts/issues/591" target="_blank" rel="noopener">https://github.com/alibaba/BizCharts/issues/591</a>)</li><li>Y轴排序使用的js自动排序，所以 toFix 保留的字符串需要转化为数值。 (<a href="https://github.com/alibaba/BizCharts/issues/330" target="_blank" rel="noopener">https://github.com/alibaba/BizCharts/issues/330</a>)</li><li>Bizcharts提供的图表组件，可以在Chart内部使用自定义的组件或者html dom</li><li>Axis组件的横纵由Geom的position决定，跟组件顺序无关</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">import DataSet from &apos;@antv/data-set&apos;;</span><br><span class="line">// ...</span><br><span class="line">render() &#123; </span><br><span class="line">    const ds = new DataSet(); </span><br><span class="line">    const dv = ds.createView().source(this.bchart || []); </span><br><span class="line">    dv.transform(&#123;  // fold展开字段 </span><br><span class="line">        type: &apos;fold&apos;, </span><br><span class="line">        fields: [&apos;count4xx&apos;, &apos;count5xx&apos;], </span><br><span class="line">        key: &apos;count&apos;, </span><br><span class="line">        value: &apos;errCount&apos;, // value字段 </span><br><span class="line">    &#125;); </span><br><span class="line">    dv.transform(&#123; </span><br><span class="line">        type: &apos;fold&apos;, </span><br><span class="line">        fields: [&apos;count4xx_percent&apos;, &apos;count5xx_percent&apos;], </span><br><span class="line">        key: &apos;percent&apos;, </span><br><span class="line">        value: &apos;errPercent&apos;, // value字段 </span><br><span class="line">    &#125;); </span><br><span class="line">    return </span><br><span class="line">    ( </span><br><span class="line">        &lt;Chart </span><br><span class="line">          height=&#123;300&#125; </span><br><span class="line">          data=&#123;dv&#125; </span><br><span class="line">          forceFit </span><br><span class="line">          padding=&#123;[&apos;auto&apos;, 60, &apos;auto&apos;, &apos;auto&apos;]&#125; </span><br><span class="line">          scale=&#123;&#123; name: &#123; alias: &apos;时间&apos;, type: &apos;time&apos;, mask: &apos;YYYY-MM-DD HH:mm:ss&apos; &#125; &#125;&#125; //name存储时间戳，设置name字段的展示格式 </span><br><span class="line">          onPlotClick=&#123;this.errClick&#125; // 事件处理 </span><br><span class="line">          onTooltipChange=&#123;this.toolShow&#125; </span><br><span class="line">        &gt; </span><br><span class="line">          &lt;Axis name=&quot;name&quot; /&gt; </span><br><span class="line">          &lt;Axis name=&quot;errCount&quot; /&gt; // fold 展开的两个字段共用一个Y轴 </span><br><span class="line">          &lt;Axis name=&quot;errPercent&quot; label=&#123;&#123; formatter(percent) &#123; return `$&#123;(+percent * 100).toFixed(1)&#125; %`; &#125; &#125;&#125; /&gt; </span><br><span class="line">          &lt;Legend </span><br><span class="line">            position=&quot;top-center&quot; </span><br><span class="line">            itemFormatter=&#123;v =&gt; (&#123; // legend 文本格式 count4xx: &apos;4xx错误数&apos;,      count5xx: &apos;5xx错误数&apos;, count4xx_percent: &apos;4xx错误率&apos;,                count5xx_percent: &apos;5xx错误率&apos;, &#125;[v])&#125; </span><br><span class="line">          /&gt; </span><br><span class="line">          &lt;Tooltip crosshairs=&#123;&#123; type: &apos;line&apos;, &#125;&#125; /&gt; </span><br><span class="line">          &lt;Geom type=&quot;interval&quot; // interval可展示bar图 color=&quot;count&quot; // 颜色对应fold处理后的key:count </span><br><span class="line">            position=&quot;name*errCount&quot; </span><br><span class="line">            tooltip=&#123;[&apos;name*count*errCount&apos;, (name, count, val) =&gt; (&#123; name: &#123; count4xx: &apos;4xx错误数&apos;, count5xx: &apos;5xx错误数&apos; &#125;[count], value: val &#125;)]&#125; </span><br><span class="line">          /&gt; </span><br><span class="line">          &lt;Geom </span><br><span class="line">            type=&quot;line&quot; // line图 color=&quot;percent&quot; </span><br><span class="line">            position=&quot;name*errPercent&quot; // position确定横纵坐标轴展示的数据字段 tooltip=&#123;[&apos;name*percent*errPercent&apos;, (name, key, val) =&gt; (&#123; </span><br><span class="line">              name: &#123; count4xx_percent: &apos;4xx错误率&apos;, count5xx_percent: &apos;5xx错误率&apos; &#125;[key], </span><br><span class="line">              value: `$&#123;(val * 100).toFixed(2)&#125;%` &#125;)</span><br><span class="line">            ]&#125; </span><br><span class="line">          /&gt; </span><br><span class="line">          // 自定义组件，可以直接在Chart中，此处模仿实现，抓取错误趋势数据 </span><br><span class="line">          &lt;div //eslint-disable-line </span><br><span class="line">            onMouseLeave=&#123;() =&gt; &#123; this.setState(&#123; confirmShow: false, errList: null &#125;); &#125;&#125; </span><br><span class="line">            style=&#123;&#123; display: (this.state.confirmShow ? &apos;block&apos; : &apos;none&apos;) &#125;</span><br><span class="line">          &lt;div style=&#123;&#123; </span><br><span class="line">                position: &apos;absolute&apos;, </span><br><span class="line">                background: &apos;#fff&apos;, </span><br><span class="line">                border: &apos;1px solid #ccc&apos;, </span><br><span class="line">                width: 300, </span><br><span class="line">                height: 80, </span><br><span class="line">                zIndex: 2, </span><br><span class="line">                top: this.state.position ? this.state.position[1] + 20 : 0, left: this.state.position ? this.state.position[0] - 150 : 0, </span><br><span class="line">                &#125;&#125; </span><br><span class="line">          &gt; </span><br><span class="line">          &#123;!this.state.errList ? </span><br><span class="line">            &lt;div&gt; </span><br><span class="line">              &lt;h4&gt;是否确认获取错误数&lt;/h4&gt; </span><br><span class="line">              &lt;Button onClick=&#123;this.confirmList&#125;&gt;确认&lt;/Button&gt; </span><br><span class="line">              &lt;Button onClick=&#123;() =&gt; this.setState(&#123; confirmShow: false &#125;)&#125;&gt;取消&lt;/Button&gt; </span><br><span class="line">            &lt;/div&gt; </span><br><span class="line">            : </span><br><span class="line">            &lt;div&gt;&#123;this.state.errList&#125;&lt;/div&gt; &#125; &lt;/div&gt; </span><br><span class="line">          &lt;/div&gt; </span><br><span class="line">      &lt;/Chart&gt; </span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;BizCharts&quot;&gt;&lt;a href=&quot;#BizCharts&quot; class=&quot;headerlink&quot; title=&quot;BizCharts&quot;&gt;&lt;/a&gt;BizCharts&lt;/h4&gt;&lt;p&gt;官网：&lt;a href=&quot;https://bizcharts.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://bizcharts.net/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单说下特性:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于 G2 封装的 React 图表库，具有 G2、React 的全部优点，可以让用户以组件的形式组合出无数种图表&lt;/li&gt;
&lt;li&gt;集成了大量的统计工具，支持多种坐标系绘制，交互定制，动画定制以及图形定制等&lt;/li&gt;
&lt;li&gt;性能稳定且具有强大的扩展能力和高度自定义能力&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="图表库" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%A1%A8%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>关于ECharts_click事件的探索</title>
    <link href="http://yoursite.com/2018/09/16/%E5%85%B3%E4%BA%8EECharts-click%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%8E%A2%E7%B4%A2/"/>
    <id>http://yoursite.com/2018/09/16/关于ECharts-click事件的探索/</id>
    <published>2018-09-16T04:19:35.000Z</published>
    <updated>2018-09-16T06:03:16.091Z</updated>
    
    <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>用echarts展示图表的时候，有时候需要点击当前图表，进行一些其他”effect side”操作,这个时候就需要得到当前这个点的横纵坐标的数据信息了。</p><hr><h4 id="探索方法"><a href="#探索方法" class="headerlink" title="探索方法"></a>探索方法</h4><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>查看官网API文档 <a href="http://www.echartsjs.com/api.html#echarts" target="_blank" rel="noopener">http://www.echartsjs.com/api.html#echarts</a>, 支持鼠标click事件，拿到基础的 line bar 图例上试验。<br>发现click触发条件是：</p><ol><li>line图需要点击到数据气泡点上，需要精准点击，数据多的时候，精准点击是困难的</li><li>bar图需要点击到柱状上，如果某几个数据bar很小，也存在精准点击困难的问题</li></ol><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>官网给出的API方法不尽如人意，去github上查找issue，发现有不少提出这问题。<br>解决方法：给出一个透明的bar坐标系重叠到图表上，透明bar的数据都是当前最大值，这样在图表对应的x轴都能实现触发点击，类似于tooltip那样方便。<br><a href="https://github.com/apache/incubator-echarts/issues/6106" target="_blank" rel="noopener">https://github.com/apache/incubator-echarts/issues/6106</a></p><p>但是，这个方法也有缺点：<br><a id="more"></a></p><ol><li>多了一个坐标系，增加了页面的数据量，加大了浏览器绘制压力</li><li>数据量大的时候，每个bar区域很小，bar之间存在空隙，准确点击也不那么容易</li></ol><p>所以，这个方法体验也不是那么好</p><h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h4><p>在试验方法二的时候，虽然准确点击体验不那么好，但hover触发的tooltip仍然十分流畅，但查看文档，tooltip虽然可以得到当前坐标的data数据，但无法判断事件。<br>所以想要tooltip那种点击得到当前数据的体验，需要结合一个click事件。</p><p>在官网示例上，找到一个click的示例， <a href="http://echarts.baidu.com/examples/editor.html?c=line-pen" target="_blank" rel="noopener">http://echarts.baidu.com/examples/editor.html?c=line-pen</a></p><p>zr的click在点击整个chart区域的时候都会触发，但往往需要排除掉图表区域外的无关区域，所以需要<code>convertFromPixel</code>转化到当前的坐标系，<code>containPixel</code>判断是否在当前坐标系中。<br>坐标点的数据呢？ 在tooltip的formatter中维护。 逻辑示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var clickParams = null;</span><br><span class="line">myChart.options.tooltip.formatter = function(params)&#123;</span><br><span class="line">    clickParams = params;</span><br><span class="line">    // return formaater string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var zr = myChart.getZr();</span><br><span class="line">zr.on(&apos;click&apos;, function (params) &#123;</span><br><span class="line">    var pointInPixel = [params.offsetX, params.offsetY];   //得到点击事件的触发点</span><br><span class="line">    var pointInGrid = myChart.convertFromPixel(&apos;grid&apos;, pointInPixel);</span><br><span class="line"></span><br><span class="line">    if (myChart.containPixel(&apos;grid&apos;, pointInPixel)) &#123;  //判断是否在坐标系中</span><br><span class="line">        // 得到clickParams， effect side 处理</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>issue讨论：<a href="https://github.com/apache/incubator-echarts/issues/3853" target="_blank" rel="noopener">https://github.com/apache/incubator-echarts/issues/3853</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h4&gt;&lt;p&gt;用echarts展示图表的时候，有时候需要点击当前图表，进行一些其他”effect side”操作,这个时候就需要得到当前这个点的横纵坐标的数据信息了。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;探索方法&quot;&gt;&lt;a href=&quot;#探索方法&quot; class=&quot;headerlink&quot; title=&quot;探索方法&quot;&gt;&lt;/a&gt;探索方法&lt;/h4&gt;&lt;h4 id=&quot;方法一&quot;&gt;&lt;a href=&quot;#方法一&quot; class=&quot;headerlink&quot; title=&quot;方法一&quot;&gt;&lt;/a&gt;方法一&lt;/h4&gt;&lt;p&gt;查看官网API文档 &lt;a href=&quot;http://www.echartsjs.com/api.html#echarts&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.echartsjs.com/api.html#echarts&lt;/a&gt;, 支持鼠标click事件，拿到基础的 line bar 图例上试验。&lt;br&gt;发现click触发条件是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;line图需要点击到数据气泡点上，需要精准点击，数据多的时候，精准点击是困难的&lt;/li&gt;
&lt;li&gt;bar图需要点击到柱状上，如果某几个数据bar很小，也存在精准点击困难的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;方法二&quot;&gt;&lt;a href=&quot;#方法二&quot; class=&quot;headerlink&quot; title=&quot;方法二&quot;&gt;&lt;/a&gt;方法二&lt;/h4&gt;&lt;p&gt;官网给出的API方法不尽如人意，去github上查找issue，发现有不少提出这问题。&lt;br&gt;解决方法：给出一个透明的bar坐标系重叠到图表上，透明bar的数据都是当前最大值，这样在图表对应的x轴都能实现触发点击，类似于tooltip那样方便。&lt;br&gt;&lt;a href=&quot;https://github.com/apache/incubator-echarts/issues/6106&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/apache/incubator-echarts/issues/6106&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但是，这个方法也有缺点：&lt;br&gt;
    
    </summary>
    
    
      <category term="echarts" scheme="http://yoursite.com/tags/echarts/"/>
    
  </entry>
  
  <entry>
    <title>记线上webpack分模块加载失败的问题</title>
    <link href="http://yoursite.com/2018/08/26/webpack%E5%88%86%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/08/26/webpack分模块加载失败的问题/</id>
    <published>2018-08-26T12:17:20.000Z</published>
    <updated>2018-09-16T06:03:31.866Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题一："><a href="#问题一：" class="headerlink" title="问题一："></a>问题一：</h3><p>用公司前端架构组给的tools工具时，在test环境下容易出现模块加载错误的问题。<br>观察发现，index.html， main.[hash].js 等资源文件缓存304， 各个路由页面引用的还是之前的hash资源，导致Jenkins新构建的资源没有被使用，而原来的资源已经被替换，找不到文件，所以出错。</p><p>将index.html 不缓存，每次 200 请求最新的，从而刷新各个资源文件。</p><h3 id="问题二："><a href="#问题二：" class="headerlink" title="问题二："></a>问题二：</h3><p>现象同样是加载失败。<br>区别1： 只有部分页面加载失败<br>区别2： 手动刷新，有时候页面又是好的，但另一个页面出问题。<br><a id="more"></a></p><p>发现在头部的script区域，路由请求资源时，请求的资源名不是对应的。例如： 页面A资源a.ja， 页面B资源b.js。<br>现象是： 进入A页面请求了b.js，B页面请求了a.js，资源出现了乱序。</p><p>再manifest中发现，fest的对应的key都是自增的数字id， 即<code>{1: &#39;a.js&#39;, 2:&#39;b.js&#39; ...}</code>。</p><p><strong>manifest标记了各个路由对应的js文件，但并不能保证每次打包编译是按路由的声明顺序，所以可能会出现<code>{1:&#39;b.js&#39;, 2:&#39;a.js&#39;}</code>这种编译状况。</strong></p><p>但同样的代码，为什么本地开发环境没出现这种状况？<br>同样都设置了<code>chunkName</code>， 但通过编译后的文件发现， 开发环境的manifest是{chunkName:’xxx.js’} 这种形式，规避了数字作为key乱序的问题。</p><p>但测试和生产环境并不是这种表现，而是数字作为key，不符合预期。<br>进入内部的webpack配置查看发现，在开发环境配置了<code>NamedChunksPlugin</code>，生成了稳定的chunkId, manifest能通过唯一的来一一对应。</p><p>资料：<a href="https://segmentfault.com/q/1010000011524513/a-1020000012187471" target="_blank" rel="noopener">https://segmentfault.com/q/1010000011524513/a-1020000012187471</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题一：&quot;&gt;&lt;a href=&quot;#问题一：&quot; class=&quot;headerlink&quot; title=&quot;问题一：&quot;&gt;&lt;/a&gt;问题一：&lt;/h3&gt;&lt;p&gt;用公司前端架构组给的tools工具时，在test环境下容易出现模块加载错误的问题。&lt;br&gt;观察发现，index.html， main.[hash].js 等资源文件缓存304， 各个路由页面引用的还是之前的hash资源，导致Jenkins新构建的资源没有被使用，而原来的资源已经被替换，找不到文件，所以出错。&lt;/p&gt;
&lt;p&gt;将index.html 不缓存，每次 200 请求最新的，从而刷新各个资源文件。&lt;/p&gt;
&lt;h3 id=&quot;问题二：&quot;&gt;&lt;a href=&quot;#问题二：&quot; class=&quot;headerlink&quot; title=&quot;问题二：&quot;&gt;&lt;/a&gt;问题二：&lt;/h3&gt;&lt;p&gt;现象同样是加载失败。&lt;br&gt;区别1： 只有部分页面加载失败&lt;br&gt;区别2： 手动刷新，有时候页面又是好的，但另一个页面出问题。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>npm的一次问题</title>
    <link href="http://yoursite.com/2018/03/03/npm%E7%9A%84%E4%B8%80%E6%AC%A1%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/03/03/npm的一次问题/</id>
    <published>2018-03-03T08:15:52.000Z</published>
    <updated>2018-03-24T13:41:38.822Z</updated>
    
    <content type="html"><![CDATA[<p>环境： win<br>用<code>npm install npm -g</code> 升级npm后， npm失效，任意指令报错 <code>ERR: cannot find module &#39;xxx&#39;</code>， 但 node指令和cnpm都正常。<br>重新安装node，仍然有问题。</p><p>解决方法：<br>删除 <code>AppData/Roaming/</code> 文件夹下的 npm 和 npm-cache文件夹后解决问题，<br>npm npm-cache 是 全局npm包的安装，所以需要重新安装全局的npm包，如 cnpm, gulp, webpack等</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;环境： win&lt;br&gt;用&lt;code&gt;npm install npm -g&lt;/code&gt; 升级npm后， npm失效，任意指令报错 &lt;code&gt;ERR: cannot find module &amp;#39;xxx&amp;#39;&lt;/code&gt;， 但 node指令和cnpm都正常。&lt;br&gt;重新安装node，仍然有问题。&lt;/p&gt;
&lt;p&gt;解决方法：&lt;br&gt;删除 &lt;code&gt;AppData/Roaming/&lt;/code&gt; 文件夹下的 npm 和 npm-cache文件夹后解决问题，&lt;br&gt;npm npm-cache 是 全局npm包的安装，所以需要重新安装全局的npm包，如 cnpm, gulp, webpack等&lt;/p&gt;
    
    </summary>
    
    
      <category term="npm" scheme="http://yoursite.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>离线缓存</title>
    <link href="http://yoursite.com/2018/02/25/%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2018/02/25/离线缓存/</id>
    <published>2018-02-25T13:31:14.000Z</published>
    <updated>2018-03-24T13:43:23.149Z</updated>
    
    <content type="html"><![CDATA[<h3 id="manifest"><a href="#manifest" class="headerlink" title="manifest"></a>manifest</h3><p>其实manifest是一个简单的文本文件，它的扩展名是任意的，定义需要缓存的文件、资源，mime-type 为 text/cache-manifest 。<br>如： <code>&lt;html lang=&quot;en&quot; manifest=&quot;index.manifest&quot;&gt;</code></p><p>优点：</p><ul><li>离线浏览，无网情况下也能正常访问</li><li>更快的加载速度，缓存在本地访问速度自然更快</li><li>减轻服务请求压力，文件缓存后不需要再次请求，只需要请求需要更新的文件</li></ul><hr><p>manifest 文件可分为三个部分：</p><ul><li>CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存</li><li>NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存</li><li>FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）</li></ul><hr><a id="more"></a><p>有三种方式更新manifest缓存：</p><ul><li>用户清空浏览器缓存</li><li>manifest文件被修改，哪怕是注释（所以可以通过修改注释来更新文件）</li><li>由程序来更新</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.applicationCache.addEventListener(&apos;updateready&apos;, function(e) &#123;</span><br><span class="line">  if (window.applicationCache.status == window.applicationCache.UPDATEREADY) &#123;</span><br><span class="line">    // Browser downloaded a new app cache.</span><br><span class="line">    // Swap it in and reload the page to get the new hotness.</span><br><span class="line">    window.applicationCache.swapCache();</span><br><span class="line">      window.location.reload();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // Manifest didn’t changed. Nothing new to server.</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure><hr><div class="tip"><br>1. 站点离线存储的容量限制是5M<br>2. 如果manifest文件，或者内部列举的某一个文件不能正常下载，整个更新过程将视为失败，浏览器继续全部使用老的缓存<br>3. 引用manifest的html必须与manifest文件同源，在同一个域下<br>4. 在manifest中使用的相对路径，相对参照物为manifest文件<br>5. CACHE MANIFEST字符串应在第一行，且必不可少<br>6. 系统会自动缓存引用清单文件的 HTML 文件<br>7. manifest文件中CACHE则与NETWORK，FALLBACK的位置顺序没有关系，如果是隐式声明需要在最前面<br>8. FALLBACK中的资源必须和manifest文件同源<br>9. 当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。<br>10. 站点中的其他页面即使没有设置manifest属性，请求的资源如果在缓存中也从缓存中访问<br>11. 当manifest文件发生改变时，资源请求本身也会触发更新<br></div>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;manifest&quot;&gt;&lt;a href=&quot;#manifest&quot; class=&quot;headerlink&quot; title=&quot;manifest&quot;&gt;&lt;/a&gt;manifest&lt;/h3&gt;&lt;p&gt;其实manifest是一个简单的文本文件，它的扩展名是任意的，定义需要缓存的文件、资源，mime-type 为 text/cache-manifest 。&lt;br&gt;如： &lt;code&gt;&amp;lt;html lang=&amp;quot;en&amp;quot; manifest=&amp;quot;index.manifest&amp;quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;离线浏览，无网情况下也能正常访问&lt;/li&gt;
&lt;li&gt;更快的加载速度，缓存在本地访问速度自然更快&lt;/li&gt;
&lt;li&gt;减轻服务请求压力，文件缓存后不需要再次请求，只需要请求需要更新的文件&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;manifest 文件可分为三个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存&lt;/li&gt;
&lt;li&gt;NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存&lt;/li&gt;
&lt;li&gt;FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="manifest" scheme="http://yoursite.com/tags/manifest/"/>
    
  </entry>
  
  <entry>
    <title>http缓存</title>
    <link href="http://yoursite.com/2018/02/25/http%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2018/02/25/http缓存/</id>
    <published>2018-02-25T12:27:32.000Z</published>
    <updated>2018-03-24T13:40:43.193Z</updated>
    
    <content type="html"><![CDATA[<h3 id="http的缓存策略"><a href="#http的缓存策略" class="headerlink" title="http的缓存策略"></a>http的缓存策略</h3><p>关键字段 Cache-Control: max-age, expires, ETag, Last-Modified</p><h4 id="优先级顺序"><a href="#优先级顺序" class="headerlink" title="优先级顺序"></a>优先级顺序</h4><ol><li><code>Cache-Control</code> : 强缓存，<code>no-cache</code>是不缓存， <code>max-age</code> 设置缓存生效时间，单位为秒(s)</li><li><code>Expires</code> : 缓存过期时间，单位是具体时间的 Date</li><li><code>ETag</code> : 资源内容的 hash 值， 如果资源没变化， <code>If-None-Match</code> 为false， 返回 304</li><li><code>Last-Modified</code> : 资源的最后修改日期，单位为秒(s)， <code>If-Modified-Since</code> 包含上一次的时间，如果一致，返回304</li></ol><h4 id="ETag-Last-Modefied"><a href="#ETag-Last-Modefied" class="headerlink" title="ETag Last-Modefied"></a>ETag Last-Modefied</h4><p>ETag是对Last-Modefied的功能补充，优先级更高。</p><ul><li>ETag是针对内容的 hash 变化，而 <code>Last-Modefied</code> 单位是秒， 对于 1s 内的多次改变无法感知。</li><li>周期性改变的资源，<code>Last-Modefied</code> 时间会改变，而内容不变的话，ETag 也不变，ETag对于缓存更有利。</li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;http的缓存策略&quot;&gt;&lt;a href=&quot;#http的缓存策略&quot; class=&quot;headerlink&quot; title=&quot;http的缓存策略&quot;&gt;&lt;/a&gt;http的缓存策略&lt;/h3&gt;&lt;p&gt;关键字段 Cache-Control: max-age, expires, ETag, Last-Modified&lt;/p&gt;
&lt;h4 id=&quot;优先级顺序&quot;&gt;&lt;a href=&quot;#优先级顺序&quot; class=&quot;headerlink&quot; title=&quot;优先级顺序&quot;&gt;&lt;/a&gt;优先级顺序&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Cache-Control&lt;/code&gt; : 强缓存，&lt;code&gt;no-cache&lt;/code&gt;是不缓存， &lt;code&gt;max-age&lt;/code&gt; 设置缓存生效时间，单位为秒(s)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Expires&lt;/code&gt; : 缓存过期时间，单位是具体时间的 Date&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ETag&lt;/code&gt; : 资源内容的 hash 值， 如果资源没变化， &lt;code&gt;If-None-Match&lt;/code&gt; 为false， 返回 304&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Last-Modified&lt;/code&gt; : 资源的最后修改日期，单位为秒(s)， &lt;code&gt;If-Modified-Since&lt;/code&gt; 包含上一次的时间，如果一致，返回304&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;ETag-Last-Modefied&quot;&gt;&lt;a href=&quot;#ETag-Last-Modefied&quot; class=&quot;headerlink&quot; title=&quot;ETag Last-Modefied&quot;&gt;&lt;/a&gt;ETag Last-Modefied&lt;/h4&gt;&lt;p&gt;ETag是对Last-Modefied的功能补充，优先级更高。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ETag是针对内容的 hash 变化，而 &lt;code&gt;Last-Modefied&lt;/code&gt; 单位是秒， 对于 1s 内的多次改变无法感知。&lt;/li&gt;
&lt;li&gt;周期性改变的资源，&lt;code&gt;Last-Modefied&lt;/code&gt; 时间会改变，而内容不变的话，ETag 也不变，ETag对于缓存更有利。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>grunt_gulp</title>
    <link href="http://yoursite.com/2018/02/13/grunt-gulp/"/>
    <id>http://yoursite.com/2018/02/13/grunt-gulp/</id>
    <published>2018-02-13T13:29:31.000Z</published>
    <updated>2018-03-24T13:40:14.881Z</updated>
    
    <content type="html"><![CDATA[<p>###<br><code>grunt</code> 与 <code>gulp</code> 其实是很像的。</p><ul><li>loadNpmTasks(‘grunt-<em>‘) === requier(‘gulp-</em>‘)    //载入处理插件</li><li>registerTask === task   //创建任务</li><li>grunt [taskName]  ==== gulp [taskName]   //执行某个任务</li></ul><p>区别：</p><ul><li>对于要处理的文件较多较大时， gulp 基于流 速度会快不少</li><li>gulp简单的<code>.src-&gt;.pipe-&gt;.dest</code>,任务流程很清晰， 而grunt是基于配置，然后创建任务，配置与任务分离，如果配置较多时，可读性就不如gulp task了</li></ul><p>为什么gulp会比grunt更受欢迎? </p><ul><li>gulp 速度更快，这个可能是更多的情况，毕竟项目一般引入的外部资源都不少，如果一点改动就执行好几秒，体验是很差的，但可以解决，对dev开发环境进行配置，资源文件单独处理，生产环境再打包压缩。</li><li>gulp 主要API就5个 <code>.src</code> <code>.dest</code> <code>.pipe</code> <code>.task</code> <code>.watch</code>， 再配合官网的指南，上手难度低，而且任务可读性会更好</li></ul><p>两者一对比， gulp 的学习成本低、易上手的优势就更大了。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###&lt;br&gt;&lt;code&gt;grunt&lt;/code&gt; 与 &lt;code&gt;gulp&lt;/code&gt; 其实是很像的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;loadNpmTasks(‘grunt-&lt;em&gt;‘) === requier(‘gulp-&lt;/em&gt;‘)    //载入处理插件&lt;/li&gt;
&lt;li&gt;registerTask === task   //创建任务&lt;/li&gt;
&lt;li&gt;grunt [taskName]  ==== gulp [taskName]   //执行某个任务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于要处理的文件较多较大时， gulp 基于流 速度会快不少&lt;/li&gt;
&lt;li&gt;gulp简单的&lt;code&gt;.src-&amp;gt;.pipe-&amp;gt;.dest&lt;/code&gt;,任务流程很清晰， 而grunt是基于配置，然后创建任务，配置与任务分离，如果配置较多时，可读性就不如gulp task了&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么gulp会比grunt更受欢迎? &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gulp 速度更快，这个可能是更多的情况，毕竟项目一般引入的外部资源都不少，如果一点改动就执行好几秒，体验是很差的，但可以解决，对dev开发环境进行配置，资源文件单独处理，生产环境再打包压缩。&lt;/li&gt;
&lt;li&gt;gulp 主要API就5个 &lt;code&gt;.src&lt;/code&gt; &lt;code&gt;.dest&lt;/code&gt; &lt;code&gt;.pipe&lt;/code&gt; &lt;code&gt;.task&lt;/code&gt; &lt;code&gt;.watch&lt;/code&gt;， 再配合官网的指南，上手难度低，而且任务可读性会更好&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两者一对比， gulp 的学习成本低、易上手的优势就更大了。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Angular1小结</title>
    <link href="http://yoursite.com/2018/02/13/Angular1%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2018/02/13/Angular1小结/</id>
    <published>2018-02-13T13:25:46.000Z</published>
    <updated>2018-03-24T13:38:56.994Z</updated>
    
    <content type="html"><![CDATA[<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>定义过滤器，返回一个filter function，在指令模板下可以进行一些筛选操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">angular.module(&apos;filterModule&apos;)</span><br><span class="line">    .filter(&apos;fileSize&apos;, function () &#123;</span><br><span class="line">      return function (value) &#123;</span><br><span class="line">        var bytes = parseInt(value, 10);</span><br><span class="line">        var byteLabel = bytes &gt; 1 ? &apos;Bytes&apos; : &apos;Byte&apos;;</span><br><span class="line">        var sizes = [byteLabel, &apos;KB&apos;, &apos;MB&apos;, &apos;GB&apos;, &apos;TB&apos;];</span><br><span class="line">        var i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));</span><br><span class="line">        return Math.round(bytes / Math.pow(1024, i), 2) + &apos; &apos; + sizes[i];</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p><hr><h3 id="factory-service"><a href="#factory-service" class="headerlink" title="factory service"></a>factory service</h3><p>factory service 都可以提供 xhr 服务，功用类似。<br>区别在于factory是返回一个实例对象， 而service是将服务绑定在this上的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">angular.module(&apos;httpModule&apos;)</span><br><span class="line">    .factory(&apos;api&apos;, function($http, $q)&#123;</span><br><span class="line">        var api = &#123;&#125;;</span><br><span class="line">        api.func1 = function()&#123;&#125;</span><br><span class="line">        api.func2 = function()&#123;&#125;</span><br><span class="line"></span><br><span class="line">        return api;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">angular.module(&apos;httpModule&apos;)</span><br><span class="line">    .service(&apos;api&apos;, function($http, $q)&#123;</span><br><span class="line">        var self = this;</span><br><span class="line">        self.func1 = function()&#123;&#125;</span><br><span class="line">        self.func2 = function()&#123;&#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p><hr><a id="more"></a><h3 id="directive"><a href="#directive" class="headerlink" title="directive"></a>directive</h3><p>指令一般用于html和dom的操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">angular.module(&apos;tabDirectives&apos;, [])</span><br><span class="line">  .directive(&apos;showTab&apos;,</span><br><span class="line">    function () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">      //  restrict: &apos;ACE&apos;,</span><br><span class="line">      //  template: &apos;&apos;,  </span><br><span class="line">      //  templateUrl: &apos;&apos;,</span><br><span class="line">        link: function (scope, element) &#123;</span><br><span class="line">          element.click(function(e) &#123;</span><br><span class="line">            e.preventDefault();</span><br><span class="line">            $(element).tab(&apos;show&apos;);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure></p><h4 id="指令中scope"><a href="#指令中scope" class="headerlink" title="指令中scope"></a>指令中scope</h4><ul><li>scope=false， 默认指令共享父的scope，两者改变数据，双向更改。</li><li>scope=true，指令初始化时继承父scope的数据，指令中scope改变之前，仍然将继承父scope的数据，但当指令中数据改变后，scope将是孤岛scope，与父scope地址分离。</li><li><p>scope={}，自定义scope，初始化一个scope对象，与父scope分离，提供了3种属性初始化方式。</p><ul><li>@ ：单项prop设置，将父scope传递到指令中</li><li>= ：与父scope双向绑定</li><li>&amp; ：指向父scope中的function</li></ul><hr></li></ul><h3 id="ngRoute"><a href="#ngRoute" class="headerlink" title="ngRoute"></a>ngRoute</h3><p>$routeProvider提供ngRoute服务，<code>.when</code>进行url匹配，指定模板url和controller，otherwise是前面没匹配到最后执行的， 类似switch的default，resolve是在切换前进行执行，data用于参数传递。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">angular.module(&apos;app&apos;, [&apos;ngRoute&apos;])</span><br><span class="line">    .config(function($routeProvider, $locationProvider) &#123;</span><br><span class="line"></span><br><span class="line">    $locationProvider.html5Mode(true);  //开启html5模式</span><br><span class="line">    //路由匹配</span><br><span class="line">    $routeProvider</span><br><span class="line">    .when(&apos;/page1&apos;, &#123;  </span><br><span class="line">        templateUrl: &apos;page1.tpl.html&apos;,  </span><br><span class="line">        controller: &apos;page1Controller&apos;  </span><br><span class="line">    &#125;)  </span><br><span class="line">    .when(&apos;/page/:id, &#123;</span><br><span class="line">        templateUrl: &apos;page.tpl.html&apos;,  </span><br><span class="line">        controller: &apos;pageController&apos; </span><br><span class="line">    &#125;)</span><br><span class="line">    .otherwise(&#123;</span><br><span class="line">      templateUrl: &apos;app.tpl.html&apos;,</span><br><span class="line">      controller: &apos;appController&apos;,</span><br><span class="line">      resolve: &#123;</span><br><span class="line">        myVar: function(authService) &#123;</span><br><span class="line">          return authService.init();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        authorizedRoles: [&apos;admin&apos;, &apos;creator&apos;, &apos;manager&apos;, &apos;guest&apos;]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    .run( function ($rootScope, $window, $location, $log) &#123;  </span><br><span class="line">        // 监听路由更改事件</span><br><span class="line">        $rootScope.$on(&apos;$routeChangeStart&apos;, function (event, current, previous) &#123;</span><br><span class="line">        if(current.$$route &amp;&amp; current.$$route.data) &#123;</span><br><span class="line">            var authorizedRoles = current.$$route.data.authorizedRoles;</span><br><span class="line">            $rootScope.notAuthorized = !authService.isAuthorized(authorizedRoles);</span><br><span class="line">        &#125;</span><br><span class="line">      );  </span><br><span class="line">    </span><br><span class="line">        $rootScope.$on(&apos;$routeChangeSuccess&apos;, function() &#123; &#125;); </span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p><hr><h3 id="digest-apply-scope-rootScope"><a href="#digest-apply-scope-rootScope" class="headerlink" title="$digest $apply $scope $rootScope"></a>$digest $apply $scope $rootScope</h3><p>$rootScope是所有$scope的上级，相当于全局的$scope<br>$digest更新自身scope和子scope， $apply从$rootScope更新</p><h3 id="event"><a href="#event" class="headerlink" title="event"></a>event</h3><p>$emit 向上<br>$broadcast 向下<br>$scope.on() 接收</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li>减少 $watch</li><li>ng-if 会卸载dom和$watch， 比ng-show效果好点</li><li>减少不必要的$digest $apply</li><li>ng-repeat track by</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;filter&quot;&gt;&lt;a href=&quot;#filter&quot; class=&quot;headerlink&quot; title=&quot;filter&quot;&gt;&lt;/a&gt;filter&lt;/h3&gt;&lt;p&gt;定义过滤器，返回一个filter function，在指令模板下可以进行一些筛选操作。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;angular.module(&amp;apos;filterModule&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .filter(&amp;apos;fileSize&amp;apos;, function () &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      return function (value) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var bytes = parseInt(value, 10);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var byteLabel = bytes &amp;gt; 1 ? &amp;apos;Bytes&amp;apos; : &amp;apos;Byte&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var sizes = [byteLabel, &amp;apos;KB&amp;apos;, &amp;apos;MB&amp;apos;, &amp;apos;GB&amp;apos;, &amp;apos;TB&amp;apos;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return Math.round(bytes / Math.pow(1024, i), 2) + &amp;apos; &amp;apos; + sizes[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;factory-service&quot;&gt;&lt;a href=&quot;#factory-service&quot; class=&quot;headerlink&quot; title=&quot;factory service&quot;&gt;&lt;/a&gt;factory service&lt;/h3&gt;&lt;p&gt;factory service 都可以提供 xhr 服务，功用类似。&lt;br&gt;区别在于factory是返回一个实例对象， 而service是将服务绑定在this上的。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;angular.module(&amp;apos;httpModule&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .factory(&amp;apos;api&amp;apos;, function($http, $q)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var api = &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        api.func1 = function()&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        api.func2 = function()&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return api;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;angular.module(&amp;apos;httpModule&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .service(&amp;apos;api&amp;apos;, function($http, $q)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var self = this;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.func1 = function()&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.func2 = function()&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="angular.js" scheme="http://yoursite.com/tags/angular-js/"/>
    
  </entry>
  
  <entry>
    <title>canvas:path2D,离屏canvas</title>
    <link href="http://yoursite.com/2018/01/14/canvas-path2D-%E7%A6%BB%E5%B1%8Fcanvas/"/>
    <id>http://yoursite.com/2018/01/14/canvas-path2D-离屏canvas/</id>
    <published>2018-01-14T07:57:02.000Z</published>
    <updated>2018-03-24T13:39:24.088Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Path2D"><a href="#Path2D" class="headerlink" title="Path2D"></a>Path2D</h2><h4 id="Path2D-概念"><a href="#Path2D-概念" class="headerlink" title="Path2D 概念"></a>Path2D 概念</h4><p>Canvas 2D API 的接口 Path2D 用来声明路径，此路径稍后会被CanvasRenderingContext2D 对象使用。CanvasRenderingContext2D 接口的 路径方法 也存在于 Path2D 这个接口中，允许你在 canvas 中根据需要创建可以保留并重用的路径。<br><strong>当前IE safari 还不支持</strong></p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>一句话， <strong>缓存图形path</strong></p><h4 id="作用场景"><a href="#作用场景" class="headerlink" title="作用场景"></a>作用场景</h4><ul><li>假如随机生成的图形，常见的方法，保存图形参数</li><li><code>clearRect</code> 清空canvas后，需要回显刚才的图形</li><li><code>isPointInPath</code> 判断事件path区域</li></ul><a id="more"></a><p>常见使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">var tmpPathArr = [];</span><br><span class="line">for ( var i=0; i&lt;10; i++ )&#123;</span><br><span class="line">    var cx = Math.floor( Math.random()*300 ),</span><br><span class="line">        cy = Math.floor( Math.random()*300 ),</span><br><span class="line">        r = Math.floor( Math.random() * 255 ),</span><br><span class="line">        g = Math.floor( Math.random() * 255 ),</span><br><span class="line">        b = Math.floor( Math.random() * 255 ) ; </span><br><span class="line"></span><br><span class="line">    ctx.beginPath();  </span><br><span class="line">    ctx.fillStyle = &apos;rgb(&apos;+r+&apos;,&apos;+g+&apos;,&apos;+b+&apos;)&apos;;</span><br><span class="line">    ctx.arc(cx, cy, 30, 0, 2*Math.PI);</span><br><span class="line">    ctx.fill();</span><br><span class="line">    //保存图形的参数</span><br><span class="line">    tmpPathArr.push( &#123;cx:cx,cy:cy,rgb:ctx.fillStyle&#125; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//清空后回显</span><br><span class="line">ctx.clearRect(0,0, canvas.width, canvas.height);</span><br><span class="line">tmpPathArr.map(function(v)&#123;</span><br><span class="line">    ctx.beginPath();  </span><br><span class="line">    ctx.fillStyle = v.rgb;</span><br><span class="line">    ctx.arc(v.cx, v.cy, 30, 0, 2*Math.PI);</span><br><span class="line">    ctx.fill();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//isPointInPath</span><br><span class="line">canvas.onmousedown = function(ev)&#123;  </span><br><span class="line">    var e = ev||event;  </span><br><span class="line">    var x = e.clientX;  </span><br><span class="line">    var y = e.clientY;  </span><br><span class="line">    tmpPathArr.map(function(v)&#123;</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.arc(v.cx, v.cy, 30, 0, 2*Math.PI);</span><br><span class="line">        if ( ctx.isPointInPath(x,y) )&#123;  </span><br><span class="line">            // 判断区域</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>使用Path2D<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">var tmpPathArr = [];</span><br><span class="line">for ( var i=0; i&lt;10; i++ )&#123;</span><br><span class="line">    var cx = Math.floor( Math.random()*300 ),</span><br><span class="line">        cy = Math.floor( Math.random()*300 ),</span><br><span class="line">        r = Math.floor( Math.random() * 255 ),</span><br><span class="line">        g = Math.floor( Math.random() * 255 ),</span><br><span class="line">        b = Math.floor( Math.random() * 255 ) ; </span><br><span class="line"></span><br><span class="line">    ctx.beginPath();  </span><br><span class="line">    ctx.fillStyle = &apos;rgb(&apos;+r+&apos;,&apos;+g+&apos;,&apos;+b+&apos;)&apos;;</span><br><span class="line"></span><br><span class="line">    //利用path2直接保存图形，然后绘制图形</span><br><span class="line">    var path2D = new Path2D();        </span><br><span class="line">    path2D.arc(cx, cy, 30, 0, 2*Math.PI);</span><br><span class="line">    path2D.rgb = ctx.fillStyle;</span><br><span class="line">    ctx.fill( path2D );</span><br><span class="line">    //保存图形的参数</span><br><span class="line">    tmpPathArr.push( path2D );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//清空后回显</span><br><span class="line">ctx.clearRect(0,0, canvas.width, canvas.height);</span><br><span class="line">tmpPathArr.map(function(v)&#123;</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.fillStyle = v.rgb;</span><br><span class="line">    ctx.fill( v );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//isPointInPath</span><br><span class="line">canvas.onmousedown = function(ev)&#123;  </span><br><span class="line">    var e = ev||event;  </span><br><span class="line">    var x = e.clientX;  </span><br><span class="line">    var y = e.clientY;  </span><br><span class="line">    tmpPathArr.map(function(v)&#123;</span><br><span class="line">        if ( ctx.isPointInPath(v, x,y) )&#123;</span><br><span class="line">            //判断区域</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="Path2优点"><a href="#Path2优点" class="headerlink" title="Path2优点"></a>Path2优点</h4><ul><li>直接保存图形，不用关心图形参数，快速绘制</li><li>判断事件区域时，简单直接的使用 <code>ctx.isPointInPath(path2D,x,y)</code> ，不用绘制缓存的图形，取得上下文context后再判断</li><li>如果是多path的复杂图形，使用path2D优势将更明显，不需要保存图形复杂的绘制参数，方便开发和使用</li></ul><h2 id="离屏canvas"><a href="#离屏canvas" class="headerlink" title="离屏canvas"></a>离屏canvas</h2><h4 id="离屏canvas-1"><a href="#离屏canvas-1" class="headerlink" title="离屏canvas"></a>离屏canvas</h4><ul><li>创建的一个不显示的canvas，方便保存画布的静态场景</li><li>减少图形的绘制，优化性能</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//创建离屏canvas</span><br><span class="line">var  offCanvas = document.createElement(&quot;canvas&quot;);  </span><br><span class="line">offCanvas.width=400;  </span><br><span class="line">offCanvas.height=400;  </span><br><span class="line">var offContext = offCanvas.getContext(&quot;2d&quot;);  </span><br><span class="line"></span><br><span class="line">for ( var i=0; i&lt;10; i++ )&#123;</span><br><span class="line">    var cx = Math.floor( Math.random()*300 ),</span><br><span class="line">        cy = Math.floor( Math.random()*300 ),</span><br><span class="line">        r = Math.floor( Math.random() * 255 ),</span><br><span class="line">        g = Math.floor( Math.random() * 255 ),</span><br><span class="line">        b = Math.floor( Math.random() * 255 ) ; </span><br><span class="line">    //在离屏canvas上绘制场景，此时图形在离屏canvas上，并不显示</span><br><span class="line">    offContext.beginPath();  </span><br><span class="line">    offContext.fillStyle = &apos;rgb(&apos;+r+&apos;,&apos;+g+&apos;,&apos;+b+&apos;)&apos;;</span><br><span class="line">    offContext.arc(cx, cy, 30, 0, 2*Math.PI);</span><br><span class="line">    offContext.fill();</span><br><span class="line">&#125;</span><br><span class="line">//drawImage直接绘制整个离屏canvas的图形</span><br><span class="line">ctx.drawImage(offCanvas,0,0);</span><br></pre></td></tr></table></figure><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>静态的背景及不变的图形，每次重绘、回显时，可以直接绘制背景及图形，优化性能</li><li>重复或相似的图形，此时，可以将离屏canvas类比Sprite，保存各种图形的不同状态，利用<code>drawImage</code> 定位图形位置和区域大小，绘制要需要的部分图形</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Path2D&quot;&gt;&lt;a href=&quot;#Path2D&quot; class=&quot;headerlink&quot; title=&quot;Path2D&quot;&gt;&lt;/a&gt;Path2D&lt;/h2&gt;&lt;h4 id=&quot;Path2D-概念&quot;&gt;&lt;a href=&quot;#Path2D-概念&quot; class=&quot;headerlink&quot; title=&quot;Path2D 概念&quot;&gt;&lt;/a&gt;Path2D 概念&lt;/h4&gt;&lt;p&gt;Canvas 2D API 的接口 Path2D 用来声明路径，此路径稍后会被CanvasRenderingContext2D 对象使用。CanvasRenderingContext2D 接口的 路径方法 也存在于 Path2D 这个接口中，允许你在 canvas 中根据需要创建可以保留并重用的路径。&lt;br&gt;&lt;strong&gt;当前IE safari 还不支持&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;作用&quot;&gt;&lt;a href=&quot;#作用&quot; class=&quot;headerlink&quot; title=&quot;作用&quot;&gt;&lt;/a&gt;作用&lt;/h4&gt;&lt;p&gt;一句话， &lt;strong&gt;缓存图形path&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;作用场景&quot;&gt;&lt;a href=&quot;#作用场景&quot; class=&quot;headerlink&quot; title=&quot;作用场景&quot;&gt;&lt;/a&gt;作用场景&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;假如随机生成的图形，常见的方法，保存图形参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clearRect&lt;/code&gt; 清空canvas后，需要回显刚才的图形&lt;/li&gt;
&lt;li&gt;&lt;code&gt;isPointInPath&lt;/code&gt; 判断事件path区域&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="canvas" scheme="http://yoursite.com/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>svgvg_bezier</title>
    <link href="http://yoursite.com/2018/01/01/svgvg-bezier/"/>
    <id>http://yoursite.com/2018/01/01/svgvg-bezier/</id>
    <published>2018-01-01T13:05:50.000Z</published>
    <updated>2018-03-24T13:41:58.835Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一种连接两个点的贝塞尔曲线"><a href="#一种连接两个点的贝塞尔曲线" class="headerlink" title="一种连接两个点的贝塞尔曲线"></a>一种连接两个点的贝塞尔曲线</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function bezier(startPoint, endPoint)&#123;</span><br><span class="line">    var sx = startPoint.x,</span><br><span class="line">        sy = startPoint.y,</span><br><span class="line">        ex = endPoint.x,</span><br><span class="line">        ey = endPoint.y,</span><br><span class="line">        length = Math.sqrt( Math.pow( (sx-ex), 2) + Math.pow( (sy-ey), 2 ) ) ;</span><br><span class="line"></span><br><span class="line">    //可以根据两点的倾斜方向做更加细致的取点，这里只列出其中一种方式</span><br><span class="line"></span><br><span class="line">    if ( Math.abs( sx - ex ) &lt; 5 )&#123;  //两个点的横坐标差值小于5，姑且认为是平行的，这里可以自行设置</span><br><span class="line">        return [startPoint, &#123;x:sx-length, y:sy&#125;, &#123;x:ex+length, y:ey&#125;, endPoint] ;</span><br><span class="line">    &#125;</span><br><span class="line">    else if ( Math.abs( sy - ey ) &lt; 5&gt; )&#123;  //纵坐标相同</span><br><span class="line">        return [startPoint, &#123;x:sx, y:sy-length&#125;, &#123;x:ex, y:ey+length&#125;, endPoint] ;        </span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;  //斜率的情况</span><br><span class="line">        var slope = (ey-sy) / (ex-sx),   //斜率</span><br><span class="line">            dx = Math.sqrt( Math.pow(length,2) / ( 1+ 1/(slope*slope) ) ),  //x坐标变化值</span><br><span class="line">            dy = Math.abs(-1/slope * dx)  ;</span><br><span class="line">        return [startPoint, &#123;x:sx-dx, y:sy-dy&#125;, &#123;x:ex+dx ,y:ey+dy&#125;, endPoint] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var pointArr = bezier(&#123;x:11, y:22&#125;, &#123;x:33, y:44&#125;);</span><br><span class="line">$(&apos;svg #path&apos;).attr(&apos;d&apos;, &apos;M&apos;+pointArr[0].x+&apos; &apos;+pointArr[0].y+&apos; C &apos;+pointArr[1].x+&apos; &apos;+pointArr[1].y+&apos;, &apos;+pointArr[2].x+&apos; &apos;+pointArr[2].y+&apos;, &apos;+pointArr[3].x+&apos; &apos;+pointArr[3].y);</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="svg-path更新问题"><a href="#svg-path更新问题" class="headerlink" title="svg path更新问题"></a>svg path更新问题</h3><p>可能有这种场景， 在插入一段svg path后， 需要更改该path的路径， 于是重新设置path 的 ‘d’ 路径path， 在F12可以看到path更改后，但页面上线条并没有改变。<br>普通的dom插入页面，调用<code>.appendChild()</code>，但svg不算dom，所以插入path，当作dom来更改无效。</p><p>##解决方法##<br><code>.createElementNS</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var path = document.createElementNS(&apos;ttp://www.w3.org/2000/svg&apos;, &apos;path&apos;);</span><br><span class="line">$(path).attr(&#123;//设置属性&#125;).append(//)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一种连接两个点的贝塞尔曲线&quot;&gt;&lt;a href=&quot;#一种连接两个点的贝塞尔曲线&quot; class=&quot;headerlink&quot; title=&quot;一种连接两个点的贝塞尔曲线&quot;&gt;&lt;/a&gt;一种连接两个点的贝塞尔曲线&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function bezier(startPoint, endPoint)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var sx = startPoint.x,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sy = startPoint.y,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ex = endPoint.x,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ey = endPoint.y,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        length = Math.sqrt( Math.pow( (sx-ex), 2) + Math.pow( (sy-ey), 2 ) ) ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //可以根据两点的倾斜方向做更加细致的取点，这里只列出其中一种方式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if ( Math.abs( sx - ex ) &amp;lt; 5 )&amp;#123;  //两个点的横坐标差值小于5，姑且认为是平行的，这里可以自行设置&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return [startPoint, &amp;#123;x:sx-length, y:sy&amp;#125;, &amp;#123;x:ex+length, y:ey&amp;#125;, endPoint] ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    else if ( Math.abs( sy - ey ) &amp;lt; 5&amp;gt; )&amp;#123;  //纵坐标相同&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return [startPoint, &amp;#123;x:sx, y:sy-length&amp;#125;, &amp;#123;x:ex, y:ey+length&amp;#125;, endPoint] ;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    else &amp;#123;  //斜率的情况&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var slope = (ey-sy) / (ex-sx),   //斜率&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            dx = Math.sqrt( Math.pow(length,2) / ( 1+ 1/(slope*slope) ) ),  //x坐标变化值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            dy = Math.abs(-1/slope * dx)  ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return [startPoint, &amp;#123;x:sx-dx, y:sy-dy&amp;#125;, &amp;#123;x:ex+dx ,y:ey+dy&amp;#125;, endPoint] ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var pointArr = bezier(&amp;#123;x:11, y:22&amp;#125;, &amp;#123;x:33, y:44&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$(&amp;apos;svg #path&amp;apos;).attr(&amp;apos;d&amp;apos;, &amp;apos;M&amp;apos;+pointArr[0].x+&amp;apos; &amp;apos;+pointArr[0].y+&amp;apos; C &amp;apos;+pointArr[1].x+&amp;apos; &amp;apos;+pointArr[1].y+&amp;apos;, &amp;apos;+pointArr[2].x+&amp;apos; &amp;apos;+pointArr[2].y+&amp;apos;, &amp;apos;+pointArr[3].x+&amp;apos; &amp;apos;+pointArr[3].y);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>axios</title>
    <link href="http://yoursite.com/2018/01/01/axios/"/>
    <id>http://yoursite.com/2018/01/01/axios/</id>
    <published>2018-01-01T12:37:02.000Z</published>
    <updated>2018-03-24T13:39:13.494Z</updated>
    
    <content type="html"><![CDATA[<p>### </p><p>简单来说，<code>axios</code>是<code>vue-resource</code>的替代品，基于Promise的HTTP请求库，适用于浏览器端和node.js。</p><hr><a id="more"></a><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// Make a request for a user with a given ID</span><br><span class="line">axios.get(&apos;/user?ID=12345&apos;)</span><br><span class="line">.then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Optionally the request above could also be done as</span><br><span class="line">axios.get(&apos;/user&apos;, &#123;</span><br><span class="line">    params: &#123;               // 参数需要在默认的params对象中</span><br><span class="line">    ID: 12345</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//Performing a POST request</span><br><span class="line">axios.post(&apos;/user&apos;, &#123;</span><br><span class="line">    firstName: &apos;Fred&apos;,</span><br><span class="line">    lastName: &apos;Flintstone&apos;</span><br><span class="line">&#125;)</span><br><span class="line">.then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//Performing multiple concurrent requests</span><br><span class="line">function getUserAccount() &#123;</span><br><span class="line">return axios.get(&apos;/user/12345&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getUserPermissions() &#123;</span><br><span class="line">return axios.get(&apos;/user/12345/permissions&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//等待两个请求都完成</span><br><span class="line">axios.all([getUserAccount(), getUserPermissions()])  </span><br><span class="line">.then(axios.spread(function (acct, perms) &#123;</span><br><span class="line">    // Both requests are now complete</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h3 id="POST-注意点"><a href="#POST-注意点" class="headerlink" title="POST 注意点"></a>POST 注意点</h3><p>axios在post请求时，默认会将参数传递为JSON,所以如果要用 <code>application/x-www-form-urlencoded</code> 传送数据，需要额外处理</p><ul><li><p>利用<code>URLSearchParams</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var params = new URLSearchParams();</span><br><span class="line">params.append(&apos;param1&apos;, &apos;value1&apos;);</span><br><span class="line">params.append(&apos;param2&apos;, &apos;value2&apos;);</span><br><span class="line">axios.post(&apos;/foo&apos;, params);</span><br></pre></td></tr></table></figure></li><li><p>利用<code>qs</code></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//全局设置参数格式</span><br><span class="line">axios.defaults.transformRequest = [function (data) &#123;</span><br><span class="line">  data = qs.stringify(data);</span><br><span class="line">  return data;</span><br><span class="line">&#125;] ;</span><br></pre></td></tr></table></figure><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>拦截器可以拦截 <code>respone</code> 和 <code>request</code>， 即拦截请求内容和响应结果。<br>比如：对于<code>respone</code>，约定了返回data中如果<code>type:&#39;login&#39;</code>， 表示处于未登录状态，需要跳转登录页，则可以进行一个interceptores设置，避免每一个请求都重复设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.response.use(function (response) &#123;</span><br><span class="line">  // Do something before request is sent</span><br><span class="line">  if ( response.data.type === &apos;login&apos; )&#123;</span><br><span class="line">    // 跳转登录页</span><br><span class="line">  &#125;</span><br><span class="line">  return response;</span><br><span class="line">&#125;, function (error) &#123;</span><br><span class="line">  // Do something with request error</span><br><span class="line">  return Promise.reject(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="关于多实例"><a href="#关于多实例" class="headerlink" title="关于多实例"></a>关于多实例</h3><p>axios支持多实例，以满足项目中不同的请求设置。 根据需要，可以设置不同的请求实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var instance1 = axios.create();</span><br><span class="line">instance1.defaults.baseURL  = &apos;http://localhost:8888&apos; ;</span><br><span class="line"></span><br><span class="line">var instance2 = axios.create();</span><br><span class="line">instance2.defaults.baseURL  = &apos;https://localhost:8888&apos; ;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;### &lt;/p&gt;
&lt;p&gt;简单来说，&lt;code&gt;axios&lt;/code&gt;是&lt;code&gt;vue-resource&lt;/code&gt;的替代品，基于Promise的HTTP请求库，适用于浏览器端和node.js。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vuex+vue-router</title>
    <link href="http://yoursite.com/2017/12/10/vuex-vue-router/"/>
    <id>http://yoursite.com/2017/12/10/vuex-vue-router/</id>
    <published>2017-12-10T10:37:46.000Z</published>
    <updated>2018-03-24T13:42:32.224Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h3><h4 id="routes"><a href="#routes" class="headerlink" title="routes"></a>routes</h4><ol><li>利用vue懒加载和webpack的代码分割，可以按需加载router组件，有效优化。<br><code>resolve =&gt; require([&#39;../components/main&#39;], resolve)</code></li><li>component 一个组件，对应 <strong>name=’default’</strong> 的 <code>router-view</code>，当然，未命名的router-view的默认name就是default， 所以有时候可以省略</li><li>components 是组件对象， key对应不同的视图名</li></ol><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Router from &apos;vue-router&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">var routes = [</span><br><span class="line">&#123;</span><br><span class="line">    path: &apos;/&apos;,</span><br><span class="line">    component: resolve =&gt; require([&apos;../components/main&apos;], resolve),</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    path: &apos;/head&apos;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        default: resolve =&gt; require([&apos;../components/head&apos;], resolve),</span><br><span class="line">        header: resolve =&gt; require([&apos;../components/header&apos;], resolve),</span><br><span class="line">        footer: resolve =&gt; require([&apos;../components/footer&apos;], resolve)      </span><br><span class="line">    &#125;,</span><br><span class="line">    children: [</span><br><span class="line">    &#123;</span><br><span class="line">        path: &apos;child1&apos;,</span><br><span class="line">        components: &#123;</span><br><span class="line">            default: resolve =&gt; require([&apos;../components/child1&apos;], resolve)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: &apos;child2&apos;,</span><br><span class="line">        component: resolve =&gt; require([&apos;../components/child2&apos;], resolve)</span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    path: &apos;/foot&apos;,</span><br><span class="line">    components:&#123;</span><br><span class="line">        default: resolve =&gt; require([&apos;../components/foot&apos;], resolve),</span><br><span class="line">        header: resolve =&gt; require([&apos;../components/header&apos;], resolve),</span><br><span class="line">        footer: resolve =&gt; require([&apos;../components/footer&apos;], resolve)      </span><br><span class="line">    &#125;  &#125;</span><br><span class="line"></span><br><span class="line">] </span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">    routes: routes,</span><br><span class="line">    linkActiveClass: &apos;route-active&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="beforeEach"><a href="#beforeEach" class="headerlink" title="beforeEach"></a>beforeEach</h4><p>常见的一种场景就是跳转路由的时候，判断是否处于登录状态，如果处于未登录状态，跳转到登录页。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach( (to, from, next) =&gt; &#123;</span><br><span class="line">    if ( !logined() )&#123;</span><br><span class="line">      next(&#123;path: &apos;/login&apos;&#125;);</span><br><span class="line">      return ;</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;) ;</span><br></pre></td></tr></table></figure><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模， 类似于Redux。</p><ol><li>state state就是Vuex存储的状态及数据，</li><li>getters getters可以理解为计算属性<code>computed</code>， 可以直接返回经过处理后的state数据</li><li>mutation mutation是同步事件操作，直接变更state，通过 <code>store.commit</code> 提交事件</li><li>action action是异步操作，提交mutation，通过mutation变更state</li></ol><h3 id="directives"><a href="#directives" class="headerlink" title="directives"></a>directives</h3><p>directives 是指令，有5种指令钩子，可以以指令的形式赋予元素响应事件的功能。</p><p>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。<br>inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。<br>update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。<br>componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。<br>unbind：只调用一次，指令与元素解绑时调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li v-list-style&gt;item&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;    </span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  directives: &#123;</span><br><span class="line">      listStyle (ele) &#123;</span><br><span class="line">              ele.style.listStyle = &apos;none&apos;;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p>组件的参数，由父组件向下传递。<br>在子组件中用props接收传递的参数， 可以用数组的形式， 更推荐在对象中列出props的类型，可以有效检查错误及增强可读性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 父组件调用， Boolean类型的border可以直接简写</span><br><span class="line">    &lt;Item :list=&quot;list&quot; :msg=&quot;msg&quot; border&gt;&lt;/Item&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  // props: [&apos;list&apos;, &apos;msg&apos;, &apos;border&apos;]</span><br><span class="line">  props: &#123;</span><br><span class="line">      list: &#123;</span><br><span class="line">        type: Array</span><br><span class="line">      &#125;,</span><br><span class="line">      msg :&#123;</span><br><span class="line">        type: String</span><br><span class="line">      &#125;,</span><br><span class="line">      border: &#123;</span><br><span class="line">          type: Boolean</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;vue-router&quot;&gt;&lt;a href=&quot;#vue-router&quot; class=&quot;headerlink&quot; title=&quot;vue-router&quot;&gt;&lt;/a&gt;vue-router&lt;/h3&gt;&lt;h4 id=&quot;routes&quot;&gt;&lt;a href=&quot;#routes&quot; class=&quot;headerlink&quot; title=&quot;routes&quot;&gt;&lt;/a&gt;routes&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;利用vue懒加载和webpack的代码分割，可以按需加载router组件，有效优化。&lt;br&gt;&lt;code&gt;resolve =&amp;gt; require([&amp;#39;../components/main&amp;#39;], resolve)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;component 一个组件，对应 &lt;strong&gt;name=’default’&lt;/strong&gt; 的 &lt;code&gt;router-view&lt;/code&gt;，当然，未命名的router-view的默认name就是default， 所以有时候可以省略&lt;/li&gt;
&lt;li&gt;components 是组件对象， key对应不同的视图名&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="vuex vue-router" scheme="http://yoursite.com/tags/vuex-vue-router/"/>
    
  </entry>
  
  <entry>
    <title>select2自定义模板</title>
    <link href="http://yoursite.com/2017/12/03/select2%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF/"/>
    <id>http://yoursite.com/2017/12/03/select2自定义模板/</id>
    <published>2017-12-03T06:29:08.000Z</published>
    <updated>2018-03-24T13:41:51.981Z</updated>
    
    <content type="html"><![CDATA[<p>select2官方文档描述的 <code>templateResult</code> option。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//自定义select2 option 展示模板</span><br><span class="line">function columnSelectFormat(selectDom)&#123;</span><br><span class="line">    selectDom.select2(&#123;templateResult:function(state)&#123;</span><br><span class="line">        var dom = $(state.element);</span><br><span class="line">        if ( !dom.val() )</span><br><span class="line">            return &apos;(value为空)&apos;;</span><br><span class="line">        var $state = $(&apos;&lt;div title=&quot;&apos;+dom.text()+&apos;&quot;&gt;&lt;span&gt;&apos;+dom.text()+&apos;&lt;/span&gt;&lt;span&gt;&apos; + dom.val() + &apos;&lt;/span&gt;&lt;/div&gt;&apos;);</span><br><span class="line">        return $state;</span><br><span class="line">    &#125;, templateSelection: function(state)&#123;</span><br><span class="line">        var dom = $(state.element);</span><br><span class="line">        if ( !dom.val() )</span><br><span class="line">            return &apos;(value为空)&apos;;</span><br><span class="line">        var $state = $(&apos;&lt;div title=&quot;&apos;+dom.text()+&apos;&quot;&gt;&lt;span&gt;&apos;+dom.text()+&apos;&lt;/span&gt;&lt;span&gt;&apos; + dom.val() + &apos;&lt;/span&gt;&lt;/div&gt;&apos;);</span><br><span class="line">        return $state;</span><br><span class="line">    &#125;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// $.prototype</span><br><span class="line">$.fn.extend(&#123;</span><br><span class="line">    columnSelectFormat: function()&#123;</span><br><span class="line">        columnSelectFormat(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;select2官方文档描述的 &lt;code&gt;templateResult&lt;/code&gt; option。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//自定义select2 option 展示模板&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function columnSelectFormat(selectDom)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    selectDom.select2(&amp;#123;templateResult:function(state)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var dom = $(state.element);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if ( !dom.val() )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return &amp;apos;(value为空)&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var $state = $(&amp;apos;&amp;lt;div title=&amp;quot;&amp;apos;+dom.text()+&amp;apos;&amp;quot;&amp;gt;&amp;lt;span&amp;gt;&amp;apos;+dom.text()+&amp;apos;&amp;lt;/span&amp;gt;&amp;lt;span&amp;gt;&amp;apos; + dom.val() + &amp;apos;&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return $state;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;, templateSelection: function(state)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var dom = $(state.element);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if ( !dom.val() )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return &amp;apos;(value为空)&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var $state = $(&amp;apos;&amp;lt;div title=&amp;quot;&amp;apos;+dom.text()+&amp;apos;&amp;quot;&amp;gt;&amp;lt;span&amp;gt;&amp;apos;+dom.text()+&amp;apos;&amp;lt;/span&amp;gt;&amp;lt;span&amp;gt;&amp;apos; + dom.val() + &amp;apos;&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return $state;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// $.prototype&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$.fn.extend(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    columnSelectFormat: function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        columnSelectFormat(this);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CodeMirror+select2显示更新问题</title>
    <link href="http://yoursite.com/2017/11/29/CodeMirror-select2%E6%98%BE%E7%A4%BA%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/11/29/CodeMirror-select2显示更新问题/</id>
    <published>2017-11-29T14:06:13.000Z</published>
    <updated>2018-03-24T13:39:28.238Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CodeMirror显示ddl未更新问题"><a href="#CodeMirror显示ddl未更新问题" class="headerlink" title="CodeMirror显示ddl未更新问题"></a>CodeMirror显示ddl未更新问题</h3><p>现象: 在配置框中回显保存的配置数据，然后显示配置框，但是CodeMirror设置的数据没有自动更新，但是点击一下ddl显示框，马上就更新了。</p><p>先用editor.doc.getValue()，查看当前的设置的数据，发现与设置的数据相同，但是页面显示没有更新为设置的值。<br>查找资料后发现，<strong><code>display:none</code> 隐藏的DOM， editor.doc.setValue(data)后，页面数据不会自动更新</strong>，解决方法是：<strong>显示配置框后，执行<code>editor.refresh()</code>进行刷新</strong></p><h3 id="select2样式宽度问题"><a href="#select2样式宽度问题" class="headerlink" title="select2样式宽度问题"></a>select2样式宽度问题</h3><p>现象：同样是在配置框设置了select初始宽度为100%，进行select2()，切换显示配置后，select2宽度只有默认宽度，不是select设置的100%</p><p>基于之前的经验，然后在<code>F12 console</code>中，对select再次进行select2()，发现样式显示正确了。<br>一样的问题，也是在隐藏的DOM中select2因为取不到select的宽度，不能自动适配，需要显示select所在的DOM后，再次进行select2()。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CodeMirror显示ddl未更新问题&quot;&gt;&lt;a href=&quot;#CodeMirror显示ddl未更新问题&quot; class=&quot;headerlink&quot; title=&quot;CodeMirror显示ddl未更新问题&quot;&gt;&lt;/a&gt;CodeMirror显示ddl未更新问题&lt;/h3&gt;&lt;p&gt;现象: 在配置框中回显保存的配置数据，然后显示配置框，但是CodeMirror设置的数据没有自动更新，但是点击一下ddl显示框，马上就更新了。&lt;/p&gt;
&lt;p&gt;先用editor.doc.getValue()，查看当前的设置的数据，发现与设置的数据相同，但是页面显示没有更新为设置的值。&lt;br&gt;查找资料后发现，&lt;strong&gt;&lt;code&gt;display:none&lt;/code&gt; 隐藏的DOM， editor.doc.setValue(data)后，页面数据不会自动更新&lt;/strong&gt;，解决方法是：&lt;strong&gt;显示配置框后，执行&lt;code&gt;editor.refresh()&lt;/code&gt;进行刷新&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;select2样式宽度问题&quot;&gt;&lt;a href=&quot;#select2样式宽度问题&quot; class=&quot;headerlink&quot; title=&quot;select2样式宽度问题&quot;&gt;&lt;/a&gt;select2样式宽度问题&lt;/h3&gt;&lt;p&gt;现象：同样是在配置框设置了select初始宽度为100%，进行select2()，切换显示配置后，select2宽度只有默认宽度，不是select设置的100%&lt;/p&gt;
&lt;p&gt;基于之前的经验，然后在&lt;code&gt;F12 console&lt;/code&gt;中，对select再次进行select2()，发现样式显示正确了。&lt;br&gt;一样的问题，也是在隐藏的DOM中select2因为取不到select的宽度，不能自动适配，需要显示select所在的DOM后，再次进行select2()。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CodeMirror select2" scheme="http://yoursite.com/tags/CodeMirror-select2/"/>
    
  </entry>
  
  <entry>
    <title>file-upload</title>
    <link href="http://yoursite.com/2017/11/27/file-upload/"/>
    <id>http://yoursite.com/2017/11/27/file-upload/</id>
    <published>2017-11-27T14:16:12.000Z</published>
    <updated>2018-03-24T13:39:38.077Z</updated>
    
    <content type="html"><![CDATA[<p>###<br>利用formData传递参数，xhr.upload.progress 方法得到上传进度 并清空input:file 当前值，可以重复上传文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;.file-btn&apos;).on(&apos;change&apos;, &apos;#fileupload&apos;, function(e)&#123;</span><br><span class="line">    var file = $(this)[0].files     //files 文件列表</span><br><span class="line"></span><br><span class="line">    for ( var i=0,len=file.length; i&lt;len; i++ )&#123;</span><br><span class="line">        var formData = new FormData();</span><br><span class="line">        formData.append(&apos;file&apos;, file[i]);</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: &apos;upload&apos;,         // upload url</span><br><span class="line">            type:&apos;post&apos;,</span><br><span class="line">            data: formData,       // 参数</span><br><span class="line">            contentType: false,</span><br><span class="line">            processData: false,</span><br><span class="line">            xhr: function()       //xhr对象，得到客户端发出去的进度</span><br><span class="line">            &#123;</span><br><span class="line">                var xhr = new XMLHttpRequest();</span><br><span class="line">                xhr.upload.addEventListener(&quot;progress&quot;, function(evt)&#123;</span><br><span class="line">                    if (evt.lengthComputable) &#123;  </span><br><span class="line">                        var percentComplete = parseInt(evt.loaded * 100 / evt.total);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, false);</span><br><span class="line">                return xhr;</span><br><span class="line">            &#125;,</span><br><span class="line">            success: function(data)&#123;</span><br><span class="line">                // 上传接口 回调处理</span><br><span class="line">                // code</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 清空当前的input:file值，可以连续上传同名文件</span><br><span class="line">    var newDom = $(this).clone().val(&apos;&apos;);  </span><br><span class="line">    $(this).remove();</span><br><span class="line">    $(&apos;.file-btn&apos;).append(newDom);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###&lt;br&gt;利用formData传递参数，xhr.upload.progress 方法得到上传进度 并清空input:file 当前值，可以重复上传文件。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$(&amp;apos;.file-btn&amp;apos;).on(&amp;apos;change&amp;apos;, &amp;apos;#fileupload&amp;apos;, function(e)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var file = $(this)[0].files     //files 文件列表&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for ( var i=0,len=file.length; i&amp;lt;len; i++ )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var formData = new FormData();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        formData.append(&amp;apos;file&amp;apos;, file[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        $.ajax(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            url: &amp;apos;upload&amp;apos;,         // upload url&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            type:&amp;apos;post&amp;apos;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            data: formData,       // 参数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            contentType: false,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            processData: false,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            xhr: function()       //xhr对象，得到客户端发出去的进度&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                var xhr = new XMLHttpRequest();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                xhr.upload.addEventListener(&amp;quot;progress&amp;quot;, function(evt)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    if (evt.lengthComputable) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        var percentComplete = parseInt(evt.loaded * 100 / evt.total);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;, false);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                return xhr;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            success: function(data)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                // 上传接口 回调处理&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                // code&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 清空当前的input:file值，可以连续上传同名文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var newDom = $(this).clone().val(&amp;apos;&amp;apos;);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $(this).remove();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $(&amp;apos;.file-btn&amp;apos;).append(newDom);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="file upload" scheme="http://yoursite.com/tags/file-upload/"/>
    
  </entry>
  
  <entry>
    <title>input file 美化</title>
    <link href="http://yoursite.com/2017/11/27/input-file-%E7%BE%8E%E5%8C%96/"/>
    <id>http://yoursite.com/2017/11/27/input-file-美化/</id>
    <published>2017-11-27T14:14:54.000Z</published>
    <updated>2018-03-24T13:40:49.374Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常见思路"><a href="#常见思路" class="headerlink" title="常见思路"></a>常见思路</h3><p>将默认的<code>input:file</code>隐藏，然后让外层容器的按钮样式展示出来。</p><h4 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h4><p>将<code>input:file</code>透明度设置为0，并设置大小，将外层的容器设置样式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;file-btn&quot;&gt;</span><br><span class="line">    &lt;a&gt;添加文件&lt;/a&gt;</span><br><span class="line">    &lt;input autocomplete=&quot;off&quot; type=&quot;file&quot; id=&quot;fileupload&quot; name=&quot;files&quot; class=&quot;add-file&quot; multiple&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.file-btn&#123;float: left;background: #004c6f;line-height: 30px;width:100px; text-align:center;position: relative; text-indent:-200em&#125;</span><br><span class="line">.add-file&#123;position: absolute;width: 100px;height: 30px;left:0;top:0;opacity: 0;cursor: pointer;&#125;</span><br></pre></td></tr></table></figure><h4 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h4><p>隐藏input:file，利用<code>label</code>标签。<br><code>label</code>有个特殊的聚焦特性，点击label区域，相当于点击其对应的input区域，有两种写法：</p><ol><li>label for id 方法， <code>&lt;label for=&quot;inputFile&quot;&gt;&lt;/label&gt;&lt;input type=&quot;file&quot; id=&quot;inputFile&quot;&gt;</code></li><li>label包含input方法, <code>&lt;label&gt;&lt;input type=&quot;file&quot;&gt;&lt;/label&gt;</code></li></ol><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;file-btn&quot;&gt;</span><br><span class="line">    &lt;label&gt;</span><br><span class="line">    &lt;a&gt;添加文件&lt;/a&gt;    </span><br><span class="line">    &lt;input autocomplete=&quot;off&quot; type=&quot;file&quot; id=&quot;fileupload&quot; name=&quot;files&quot; class=&quot;add-file&quot; multiple&gt;</span><br><span class="line">    &lt;/label&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.file-btn&#123;float: left;background: #004c6f;line-height: 30px;width:100px; text-align:center;position: relative;&#125;</span><br><span class="line">.add-file&#123;display:none&apos;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常见思路&quot;&gt;&lt;a href=&quot;#常见思路&quot; class=&quot;headerlink&quot; title=&quot;常见思路&quot;&gt;&lt;/a&gt;常见思路&lt;/h3&gt;&lt;p&gt;将默认的&lt;code&gt;input:file&lt;/code&gt;隐藏，然后让外层容器的按钮样式展示出来。&lt;/p&gt;
&lt;h4 id=&quot;方法1：&quot;&gt;&lt;a href=&quot;#方法1：&quot; class=&quot;headerlink&quot; title=&quot;方法1：&quot;&gt;&lt;/a&gt;方法1：&lt;/h4&gt;&lt;p&gt;将&lt;code&gt;input:file&lt;/code&gt;透明度设置为0，并设置大小，将外层的容器设置样式。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;div class=&amp;quot;file-btn&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;a&amp;gt;添加文件&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;input autocomplete=&amp;quot;off&amp;quot; type=&amp;quot;file&amp;quot; id=&amp;quot;fileupload&amp;quot; name=&amp;quot;files&amp;quot; class=&amp;quot;add-file&amp;quot; multiple&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.file-btn&amp;#123;float: left;background: #004c6f;line-height: 30px;width:100px; text-align:center;position: relative; text-indent:-200em&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.add-file&amp;#123;position: absolute;width: 100px;height: 30px;left:0;top:0;opacity: 0;cursor: pointer;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;方法2：&quot;&gt;&lt;a href=&quot;#方法2：&quot; class=&quot;headerlink&quot; title=&quot;方法2：&quot;&gt;&lt;/a&gt;方法2：&lt;/h4&gt;&lt;p&gt;隐藏input:file，利用&lt;code&gt;label&lt;/code&gt;标签。&lt;br&gt;&lt;code&gt;label&lt;/code&gt;有个特殊的聚焦特性，点击label区域，相当于点击其对应的input区域，有两种写法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;label for id 方法， &lt;code&gt;&amp;lt;label for=&amp;quot;inputFile&amp;quot;&amp;gt;&amp;lt;/label&amp;gt;&amp;lt;input type=&amp;quot;file&amp;quot; id=&amp;quot;inputFile&amp;quot;&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;label包含input方法, &lt;code&gt;&amp;lt;label&amp;gt;&amp;lt;input type=&amp;quot;file&amp;quot;&amp;gt;&amp;lt;/label&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="input:file" scheme="http://yoursite.com/tags/input-file/"/>
    
  </entry>
  
  <entry>
    <title>gulp多任务</title>
    <link href="http://yoursite.com/2017/04/15/gulp%E5%A4%9A%E4%BB%BB%E5%8A%A1/"/>
    <id>http://yoursite.com/2017/04/15/gulp多任务/</id>
    <published>2017-04-15T12:15:12.000Z</published>
    <updated>2018-03-24T13:40:20.906Z</updated>
    
    <content type="html"><![CDATA[<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ol><li>同时处理多个web文件</li><li>css js 压缩合并</li><li>资源版本号替换</li><li>监听资源变化，进行压缩合并操作</li></ol><h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4><pre><code>/resources    /common                //common源文件    /js    /sass    /libs                  //资源库文件    /dist        /testA            lib.min.js            lib.min.css            testA.js            testA.css        /testB            lib.min.js            lib.min.css            testB.js            testB.css        /common              common.css            common.js  </code></pre><p>/resources/common 是公共的common.css common.js 源文件， 构建后在 /dist/common/ 下<br>/resources/sass, resources/js 是.scss .js 源文件</p><a id="more"></a><h5 id="单web配置文件"><a href="#单web配置文件" class="headerlink" title="单web配置文件"></a>单web配置文件</h5><pre><code>testA_gulp.js    export {        libsJs : &apos;xxx&apos;,        libsCss : &apos;xxx&apos;,        filename : &apos;testA&apos;,        mainCss : &apos;testA.scss&apos;,        mainJs : &apos;testA.js&apos;    }testB_gulp.js    export {        libsJs : &apos;xxx&apos;,        libsCss : &apos;xxx&apos;,        filename : &apos;testB&apos;,        mainCss : &apos;testB.scss&apos;,        mainJs : &apos;testB.js&apos;    }</code></pre><h4 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h4><p>gulp [taskType] [–file testA[,testB]]</p><h5 id="taskType"><a href="#taskType" class="headerlink" title="taskType"></a>taskType</h5><p>default : 默认包含 common 和 config<br>common : 公共资源 /common 的构建<br>config ：web资源的构建，即 lib.min.css lib.min.js file.css file.js, 生成在 /dist/file 文件夹下<br>version ： replace 替换的方法 更新版本号</p><p>不加 –file 参数，则会将 /gulpTask 下的配置文件都读取<br>–file testA,testB 多文件用 , 隔开</p><h4 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h4><pre><code>{&quot;devDependencies&quot;: {    &quot;gulp&quot;: &quot;*&quot;,    &quot;gulp-asset-rev&quot;: &quot;*&quot;,    &quot;gulp-autoprefixer&quot;: &quot;*&quot;,    &quot;gulp-changed&quot;: &quot;*&quot;,    &quot;gulp-concat&quot;: &quot;*&quot;,    &quot;gulp-csslint&quot;: &quot;*&quot;,    &quot;gulp-csso&quot;: &quot;*&quot;,    &quot;gulp-htmlmin&quot;: &quot;*&quot;,    &quot;gulp-jshint&quot;: &quot;*&quot;,    &quot;gulp-load-plugins&quot;: &quot;*&quot;,    &quot;gulp-rename&quot;: &quot;*&quot;,    &quot;gulp-rev&quot;: &quot;^7.1.2&quot;,    &quot;gulp-rev-collector&quot;: &quot;^1.0.5&quot;,    &quot;gulp-sass&quot;: &quot;*&quot;,    &quot;gulp-uglify&quot;: &quot;*&quot;,    &quot;gulp-util&quot;: &quot;*&quot;,    &quot;jshint&quot;: &quot;*&quot;,    &quot;run-sequence&quot;: &quot;*&quot;,    &quot;wrench&quot;: &quot;^1.59&quot;,    &quot;gulp-replace&quot;: &quot;*&quot;},&quot;engines&quot;: {    &quot;node&quot;: &quot;&gt;=4.0&quot;}}</code></pre><h4 id="gulpfile-js"><a href="#gulpfile-js" class="headerlink" title="gulpfile.js"></a>gulpfile.js</h4><pre><code>var wrench = require(&apos;wrench&apos;),    gulp = require(&apos;gulp&apos;),    replace = require(&apos;gulp-replace&apos;),    uglify = require(&apos;gulp-uglify&apos;),    sass = require(&apos;gulp-sass&apos;),    csso = require(&apos;gulp-csso&apos;),     concat = require(&apos;gulp-concat&apos;) ;var resDir = &apos;../resources/&apos;;var minimist = require(&apos;minimist&apos;);var knownOptions = {string: &apos;file&apos;,default: &apos;&apos;};var options = minimist(process.argv.slice(2), knownOptions);if ( options.file ){    var fileArr = options.file.split(&apos;,&apos;),        configs = [] ;    for ( var i=0,len=fileArr.length; i&lt;len; i++ ){        configs.push(require(&apos;./gulpTask/&apos;+fileArr[i]+&apos;_gulp.js&apos;));    }}else{    var configs = wrench.readdirSyncRecursive(&apos;./gulpTask&apos;).filter(function(file) {    return (/^\w+_gulp\.js$/g).test(file);    }).map(function(file) {    return require(&apos;./gulpTask/&apos; + file);    });};gulp.task(&apos;common&apos;, commonTask);gulp.task(&apos;config&apos;, function(){configs.map(function(v){    configTask(v);});});gulp.task(&apos;default&apos;, [&apos;common&apos;, &apos;config&apos;]);// 给 .js .css 文件加时间戳var timestamp = Date.now();gulp.task(&apos;version&apos;, function(){configs.map(function(v){    version(v);});});function version(v){  gulp.src(resDir+v.fileDir+v.filename+&apos;.vm&apos;)    .pipe(replace(/\/((\w|-|\.)+)\.js(\?v=\w+)?/g, &apos;/$1.js?v=&apos;+timestamp))    .pipe(replace(/\/((\w|-|\.)+)\.css(\?v=\w+)?/g, &apos;/$1.css?v=&apos;+timestamp))    .pipe(gulp.dest(resDir+v.fileDir));}function commonTask(){var commonCss = resDir+&apos;common/*.css&apos;,    commonJs = resDir+&apos;common/*.js&apos;  ;gulp.task(&apos;jsCommon&apos;, function(){    return gulp.src(commonJs)            .pipe(uglify())            .pipe(gulp.dest(resDir+&apos;dist/common&apos;));});gulp.task(&apos;cssCommon&apos;, function(){    return gulp.src(commonCss)        .pipe(csso())        .pipe(gulp.dest(resDir+&apos;dist/common&apos;));});gulp.watch(commonJs, [&apos;jsCommon&apos;]);gulp.watch(commonCss, [&apos;cssCommon&apos;]);gulp.start([&apos;jsCommon&apos;, &apos;cssCommon&apos;]);}function configTask(config){var libsJs = config.libsJs,    libsCss = config.libsCss,    filename = config.filename,    mainCss = resDir+config.mainCss,    mainJs = resDir+config.mainJs ;libsJs = libsJs.map(function(v){    return (v = resDir + v);});libsCss = libsCss.map(function(v){    return (v = resDir + v);});gulp.task(&apos;jsLibs:&apos;+filename, function(){    return gulp.src(libsJs)        .pipe(uglify())        .pipe(concat(&apos;libs.min.js&apos;))        .pipe(gulp.dest(resDir+&apos;dist/&apos;+filename));});gulp.task(&apos;jsMain:&apos;+filename, function(){    return gulp.src(mainJs)            .pipe(uglify())            .pipe(gulp.dest(resDir+&apos;dist/&apos;+filename));});gulp.task(&apos;jsInit:&apos;+filename, [&apos;jsLibs:&apos;+filename, &apos;jsMain:&apos;+filename]);gulp.task(&apos;jsWatch:&apos;+filename, function(){    gulp.watch(libsJs, [&apos;jsLibs:&apos;+filename]);    gulp.watch(mainJs, [&apos;jsMain:&apos;+filename]);});gulp.task(&apos;cssLibs:&apos;+filename, function(){    return gulp.src(libsCss)        .pipe(csso())        .pipe(concat(&apos;libs.min.css&apos;))        .pipe(gulp.dest(resDir+&apos;dist/&apos;+filename));});gulp.task(&apos;cssMain:&apos;+filename, function(){    return gulp.src(mainCss)        .pipe(sass())        .pipe(csso())        .pipe(gulp.dest(resDir+&apos;dist/&apos;+filename));});gulp.task(&apos;cssInit:&apos;+filename, [&apos;cssLibs:&apos;+filename, &apos;cssMain:&apos;+filename]);gulp.task(&apos;cssWatch:&apos;+filename, function(){    gulp.watch(libsCss, [&apos;cssLibs:&apos;+filename]);    gulp.watch(mainCss, [&apos;cssMain:&apos;+filename]);});gulp.task(&apos;init:&apos;+filename, [&apos;jsInit:&apos;+filename, &apos;cssInit:&apos;+filename]);gulp.task(&apos;watch:&apos;+filename, [&apos;jsWatch:&apos;+filename, &apos;cssWatch:&apos;+filename]);gulp.start([&apos;init:&apos;+filename, &apos;watch:&apos;+filename]);}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;功能&quot;&gt;&lt;a href=&quot;#功能&quot; class=&quot;headerlink&quot; title=&quot;功能&quot;&gt;&lt;/a&gt;功能&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;同时处理多个web文件&lt;/li&gt;
&lt;li&gt;css js 压缩合并&lt;/li&gt;
&lt;li&gt;资源版本号替换&lt;/li&gt;
&lt;li&gt;监听资源变化，进行压缩合并操作&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;项目结构&quot;&gt;&lt;a href=&quot;#项目结构&quot; class=&quot;headerlink&quot; title=&quot;项目结构&quot;&gt;&lt;/a&gt;项目结构&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;/resources
    /common                //common源文件
    /js
    /sass
    /libs                  //资源库文件
    /dist
        /testA
            lib.min.js
            lib.min.css
            testA.js
            testA.css
        /testB
            lib.min.js
            lib.min.css
            testB.js
            testB.css
        /common  
            common.css
            common.js  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;/resources/common 是公共的common.css common.js 源文件， 构建后在 /dist/common/ 下&lt;br&gt;/resources/sass, resources/js 是.scss .js 源文件&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>restful http method</title>
    <link href="http://yoursite.com/2017/04/15/http-method-%E5%8C%BA%E5%88%86/"/>
    <id>http://yoursite.com/2017/04/15/http-method-区分/</id>
    <published>2017-04-15T11:47:43.000Z</published>
    <updated>2018-03-24T13:40:37.553Z</updated>
    
    <content type="html"><![CDATA[<p>POST GET PUT DELETE 4种方式大概类似与 “CRUD”.</p><p>POST 相当于 新建资源<br>GET 从服务端接受资源<br>PUT 更新资源<br>DELETE 删除资源</p><p><em>幂等的概念：  f(x) = f( f( f( f(x) ) ) )</em></p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>GET  get 是安全的， 即不会更改服务端资源， 一个GET请求， 1次或者多次， 得到的结果是一样的， 具有幂等性。<br>POST 新建资源会有副作用，即 会增加资源， 不是安全的， 多次请求会产生多个新建资源，是非幂等的。<br>PUT 更新资源，提交相同的更新数据，1次更新或者多次更新， 更新的资源是一样的， 所以是 幂等的。<br>DELETE 一次或多次删除一个资源， 结果都是删除目标资源， 是幂等的</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;POST GET PUT DELETE 4种方式大概类似与 “CRUD”.&lt;/p&gt;
&lt;p&gt;POST 相当于 新建资源&lt;br&gt;GET 从服务端接受资源&lt;br&gt;PUT 更新资源&lt;br&gt;DELETE 删除资源&lt;/p&gt;
&lt;p&gt;&lt;em&gt;幂等的概念：  f(x) = f( f( f( f(x) ) ) )&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&quot;区别&quot;&gt;&lt;a href=&quot;#区别&quot; class=&quot;headerlink&quot; title=&quot;区别&quot;&gt;&lt;/a&gt;区别&lt;/h4&gt;&lt;p&gt;GET  get 是安全的， 即不会更改服务端资源， 一个GET请求， 1次或者多次， 得到的结果是一样的， 具有幂等性。&lt;br&gt;POST 新建资源会有副作用，即 会增加资源， 不是安全的， 多次请求会产生多个新建资源，是非幂等的。&lt;br&gt;PUT 更新资源，提交相同的更新数据，1次更新或者多次更新， 更新的资源是一样的， 所以是 幂等的。&lt;br&gt;DELETE 一次或多次删除一个资源， 结果都是删除目标资源， 是幂等的&lt;/p&gt;
    
    </summary>
    
    
      <category term="http method" scheme="http://yoursite.com/tags/http-method/"/>
    
  </entry>
  
</feed>
