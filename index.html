<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> CDBlog</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="CDBlog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/03/02/排序与树的遍历算法实现/" class="post-title-link">排序与树的遍历算法实现</a></h2><div class="post-info">Mar 2, 2019</div><div class="post-content"><p>// 冒泡<br>function sort1(arr){<br>  for ( let i=0, len=arr.length; i&lt;len-1; i++ ){<br>    for ( let j=i+1; j&lt;=len-1; j++ ){<br>      if ( arr[i] &gt; arr[j] ){<br>        let tmp = arr[i];<br>        arr[i] = arr[j];<br>        arr[j] = tmp;<br>      }<br>    }<br>  }<br>  return arr;<br>}</p>
<p>// 插入<br>function sort2(arr){<br>  for ( let i=1, len=arr.length; i&lt;=len-1; i++ ){<br>    var tmp = arr[i];<br>    for ( var j=i-1; j&gt;=0; j– ){<br>      if ( arr[j] &gt; tmp ){<br>        arr[j+1] = arr[j];<br>      }<br>      else {<br>        break ;<br>      }<br>    }<br>    arr[j+1] = tmp;<br>  }<br>  return arr;<br>}</p></div><a href="/2019/03/02/排序与树的遍历算法实现/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/03/02/初次开发hybrid-H5的坑及方案/" class="post-title-link">初次开发hybrid H5的坑及方案</a></h2><div class="post-info">Mar 2, 2019</div><div class="post-content"><h4 id="hybrid-h5"><a href="#hybrid-h5" class="headerlink" title="hybrid h5"></a>hybrid h5</h4><p>hybrid 翻译为杂交， hyrid h5 是指将web前端页面嵌入到原生APP( iOS和Android )中的运行的方案。<br>相对于原生开发，web前端的开发发展时间更长、从业人员更多、生态更为繁荣，而且开发效率也更高。<br>但web并不能直接调用原生API，而且运行内存、调度也差与原生，流畅性就显得不足。<br>基于以上原因，协调开发资源，将一些展示性、交互不多的页面让web开发，嵌入原生Webview中运行，就可以大大提高APP开发效率，利用团队开发资源。</p></div><a href="/2019/03/02/初次开发hybrid-H5的坑及方案/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/12/02/小程序探索/" class="post-title-link">小程序探索</a></h2><div class="post-info">Dec 2, 2018</div><div class="post-content"><h3 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h3><ul>
<li>小程序需要申请账号，主体可以是企业，也可以是个人，里面有小程序的AppID，配置服务地址(比如localhost)</li>
<li>小程序开发工具，创建工程需要AppID</li>
<li>开发工具包含代码编辑器+调试器+客户端模拟器+版本管理器，基本做到了一站式开发</li>
<li>模拟器只有ios和 nexus，再加上原生组件，真机调试不可少</li>
</ul>
<h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><p>整个框架像个大杂烩，整体设计并不统一，包含了OO、函数式和面向过程。或许，是为了不同技术栈背景的开发人员都能找到一套适合的开发模式。</p>
<ul>
<li>样式层上来看，wxss像个css的子集，缺少了一些特性支持</li>
<li>模板wxml来看，Mustache语法，类似ng1.js的语法，数据与视图绑定，但数据流不是双向，不是响应式，而是类似React语法的setData，异步单项数据流</li>
<li>逻辑层js中，Page(Object)类似于Vue1的data设置，逻辑方法写法，同时也包含生命周期函数，可直接访问路由</li>
<li>wxs和template可直接在wxml中扩展，分别对应了script和模板引擎，可在多个地方引入调用，虽然提供了组件，但开发并不是组件化</li>
</ul>
<hr></div><a href="/2018/12/02/小程序探索/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/11/29/BizCharts调研/" class="post-title-link">BizCharts调研</a></h2><div class="post-info">Nov 29, 2018</div><div class="post-content"><h4 id="BizCharts"><a href="#BizCharts" class="headerlink" title="BizCharts"></a>BizCharts</h4><p>官网：<a href="https://bizcharts.net/" target="_blank" rel="noopener">https://bizcharts.net/</a></p>
<p>简单说下特性:</p>
<ul>
<li>基于 G2 封装的 React 图表库，具有 G2、React 的全部优点，可以让用户以组件的形式组合出无数种图表</li>
<li>集成了大量的统计工具，支持多种坐标系绘制，交互定制，动画定制以及图形定制等</li>
<li>性能稳定且具有强大的扩展能力和高度自定义能力</li>
</ul>
<hr></div><a href="/2018/11/29/BizCharts调研/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/09/16/关于ECharts-click事件的探索/" class="post-title-link">关于ECharts_click事件的探索</a></h2><div class="post-info">Sep 16, 2018</div><div class="post-content"><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>用echarts展示图表的时候，有时候需要点击当前图表，进行一些其他”effect side”操作,这个时候就需要得到当前这个点的横纵坐标的数据信息了。</p>
<hr>
<h4 id="探索方法"><a href="#探索方法" class="headerlink" title="探索方法"></a>探索方法</h4><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>查看官网API文档 <a href="http://www.echartsjs.com/api.html#echarts" target="_blank" rel="noopener">http://www.echartsjs.com/api.html#echarts</a>, 支持鼠标click事件，拿到基础的 line bar 图例上试验。<br>发现click触发条件是：</p>
<ol>
<li>line图需要点击到数据气泡点上，需要精准点击，数据多的时候，精准点击是困难的</li>
<li>bar图需要点击到柱状上，如果某几个数据bar很小，也存在精准点击困难的问题</li>
</ol>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>官网给出的API方法不尽如人意，去github上查找issue，发现有不少提出这问题。<br>解决方法：给出一个透明的bar坐标系重叠到图表上，透明bar的数据都是当前最大值，这样在图表对应的x轴都能实现触发点击，类似于tooltip那样方便。<br><a href="https://github.com/apache/incubator-echarts/issues/6106" target="_blank" rel="noopener">https://github.com/apache/incubator-echarts/issues/6106</a></p>
<p>但是，这个方法也有缺点：<br></div><a href="/2018/09/16/关于ECharts-click事件的探索/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/08/26/webpack分模块加载失败的问题/" class="post-title-link">记线上webpack分模块加载失败的问题</a></h2><div class="post-info">Aug 26, 2018</div><div class="post-content"><h3 id="问题一："><a href="#问题一：" class="headerlink" title="问题一："></a>问题一：</h3><p>用公司前端架构组给的tools工具时，在test环境下容易出现模块加载错误的问题。<br>观察发现，index.html， main.[hash].js 等资源文件缓存304， 各个路由页面引用的还是之前的hash资源，导致Jenkins新构建的资源没有被使用，而原来的资源已经被替换，找不到文件，所以出错。</p>
<p>将index.html 不缓存，每次 200 请求最新的，从而刷新各个资源文件。</p>
<h3 id="问题二："><a href="#问题二：" class="headerlink" title="问题二："></a>问题二：</h3><p>现象同样是加载失败。<br>区别1： 只有部分页面加载失败<br>区别2： 手动刷新，有时候页面又是好的，但另一个页面出问题。<br></div><a href="/2018/08/26/webpack分模块加载失败的问题/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/03/03/npm的一次问题/" class="post-title-link">npm的一次问题</a></h2><div class="post-info">Mar 3, 2018</div><div class="post-content"><p>环境： win<br>用<code>npm install npm -g</code> 升级npm后， npm失效，任意指令报错 <code>ERR: cannot find module &#39;xxx&#39;</code>， 但 node指令和cnpm都正常。<br>重新安装node，仍然有问题。</p>
<p>解决方法：<br>删除 <code>AppData/Roaming/</code> 文件夹下的 npm 和 npm-cache文件夹后解决问题，<br>npm npm-cache 是 全局npm包的安装，所以需要重新安装全局的npm包，如 cnpm, gulp, webpack等</p></div><a href="/2018/03/03/npm的一次问题/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/02/25/离线缓存/" class="post-title-link">离线缓存</a></h2><div class="post-info">Feb 25, 2018</div><div class="post-content"><h3 id="manifest"><a href="#manifest" class="headerlink" title="manifest"></a>manifest</h3><p>其实manifest是一个简单的文本文件，它的扩展名是任意的，定义需要缓存的文件、资源，mime-type 为 text/cache-manifest 。<br>如： <code>&lt;html lang=&quot;en&quot; manifest=&quot;index.manifest&quot;&gt;</code></p>
<p>优点：</p>
<ul>
<li>离线浏览，无网情况下也能正常访问</li>
<li>更快的加载速度，缓存在本地访问速度自然更快</li>
<li>减轻服务请求压力，文件缓存后不需要再次请求，只需要请求需要更新的文件</li>
</ul>
<hr>
<p>manifest 文件可分为三个部分：</p>
<ul>
<li>CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存</li>
<li>NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存</li>
<li>FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）</li>
</ul>
<hr></div><a href="/2018/02/25/离线缓存/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/02/25/http缓存/" class="post-title-link">http缓存</a></h2><div class="post-info">Feb 25, 2018</div><div class="post-content"><h3 id="http的缓存策略"><a href="#http的缓存策略" class="headerlink" title="http的缓存策略"></a>http的缓存策略</h3><p>关键字段 Cache-Control: max-age, expires, ETag, Last-Modified</p>
<h4 id="优先级顺序"><a href="#优先级顺序" class="headerlink" title="优先级顺序"></a>优先级顺序</h4><ol>
<li><code>Cache-Control</code> : 强缓存，<code>no-cache</code>是不缓存， <code>max-age</code> 设置缓存生效时间，单位为秒(s)</li>
<li><code>Expires</code> : 缓存过期时间，单位是具体时间的 Date</li>
<li><code>ETag</code> : 资源内容的 hash 值， 如果资源没变化， <code>If-None-Match</code> 为false， 返回 304</li>
<li><code>Last-Modified</code> : 资源的最后修改日期，单位为秒(s)， <code>If-Modified-Since</code> 包含上一次的时间，如果一致，返回304</li>
</ol>
<h4 id="ETag-Last-Modefied"><a href="#ETag-Last-Modefied" class="headerlink" title="ETag Last-Modefied"></a>ETag Last-Modefied</h4><p>ETag是对Last-Modefied的功能补充，优先级更高。</p>
<ul>
<li>ETag是针对内容的 hash 变化，而 <code>Last-Modefied</code> 单位是秒， 对于 1s 内的多次改变无法感知。</li>
<li>周期性改变的资源，<code>Last-Modefied</code> 时间会改变，而内容不变的话，ETag 也不变，ETag对于缓存更有利。</li>
</ul></div><a href="/2018/02/25/http缓存/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/02/13/grunt-gulp/" class="post-title-link">grunt_gulp</a></h2><div class="post-info">Feb 13, 2018</div><div class="post-content"><p>###<br><code>grunt</code> 与 <code>gulp</code> 其实是很像的。</p>
<ul>
<li>loadNpmTasks(‘grunt-<em>‘) === requier(‘gulp-</em>‘)    //载入处理插件</li>
<li>registerTask === task   //创建任务</li>
<li>grunt [taskName]  ==== gulp [taskName]   //执行某个任务</li>
</ul>
<p>区别：</p>
<ul>
<li>对于要处理的文件较多较大时， gulp 基于流 速度会快不少</li>
<li>gulp简单的<code>.src-&gt;.pipe-&gt;.dest</code>,任务流程很清晰， 而grunt是基于配置，然后创建任务，配置与任务分离，如果配置较多时，可读性就不如gulp task了</li>
</ul>
<p>为什么gulp会比grunt更受欢迎? </p>
<ul>
<li>gulp 速度更快，这个可能是更多的情况，毕竟项目一般引入的外部资源都不少，如果一点改动就执行好几秒，体验是很差的，但可以解决，对dev开发环境进行配置，资源文件单独处理，生产环境再打包压缩。</li>
<li>gulp 主要API就5个 <code>.src</code> <code>.dest</code> <code>.pipe</code> <code>.task</code> <code>.watch</code>， 再配合官网的指南，上手难度低，而且任务可读性会更好</li>
</ul>
<p>两者一对比， gulp 的学习成本低、易上手的优势就更大了。</p></div><a href="/2018/02/13/grunt-gulp/" class="read-more">...more</a></article></li></ul></main><footer><div class="paginator"><a href="/page/2/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">chendong</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>