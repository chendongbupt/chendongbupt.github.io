<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> CDBlog</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="CDBlog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/10/07/cfca的一个加密失败的问题/" class="post-title-link">cfca的一个加密失败的问题</a></h2><div class="post-info">Oct 7, 2019</div><div class="post-content"><p>在金融领域，cfca(中国金融认证中心)是必然会接触的，使用了cfca键盘，提供了客户端到服务端的加解密功能。</p>
<p>在某个需求时遇到一个cfca加解密失败。</p>
<p>功能伪代码如下, 先接口获取开关配置，再决定展示UI。</p></div><a href="/2019/10/07/cfca的一个加密失败的问题/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/10/07/移动端iOS部分兼容/" class="post-title-link">移动端iOS部分兼容</a></h2><div class="post-info">Oct 7, 2019</div><div class="post-content"><ol>
<li>iOS引入图片资源时，在https下因为安全机制，不能渲染http的图片</li>
<li>img标签的onload事件无法在iOS中识别，但js的onload则可以。 <img src="http://src..." onload=""> 替换为 {const img = new Image(); img.onload=function(e){}; img.src=”<a href="http://src...&quot;}" target="_blank" rel="noopener">http://src...&quot;}</a>;</li>
<li>iOS下的input光标层级较高，会在弹出的mask层上展示，需要在 input 的父元素增加<code>postion:relative</code></li>
<li>input输入时，iOS键盘弹起，关闭键盘后，页面内容不自动回弹。iOS下还存在 <code>focusin</code> <code>focusout</code> 表单两个事件，监听focusout时，页面进行dom回弹即可。</li>
<li>iOS不像安卓一样，存在开放的文件夹入口，只提供了图片/视频的入口。 当iOS下载文件时，比如word pdf，需要先用APP授权并打开，之后在APP中进行访问。APP间类似独立沙盒，数据不能直接互通。<br>所以，涉及文件下载的功能点时，需要考虑这点。比如，提供预览，和复制url，引导用户外部下载。</li>
</ol></div><a href="/2019/10/07/移动端iOS部分兼容/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/10/07/css实现文字镂空/" class="post-title-link">css实现文字镂空</a></h2><div class="post-info">Oct 7, 2019</div><div class="post-content"></div><a href="/2019/10/07/css实现文字镂空/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/05/04/改变上下文bind-apply-call/" class="post-title-link">改变上下文bind apply call</a></h2><div class="post-info">May 4, 2019</div><div class="post-content"><p>bind 返回一个函数， call apply 直接执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// bind</span><br><span class="line">if ( !Function.prototype.bind )&#123;</span><br><span class="line">Function.prototype.bind = function(context)&#123;</span><br><span class="line">  if ( typeof this !== &apos;function&apos; )&#123;</span><br><span class="line">    console.log(&apos;this is not function&apos;);</span><br><span class="line">    throw new Error(&apos;this is not function&apos;);</span><br><span class="line">    return ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var args = Array.prototype.slice.call(arguments, 1),</span><br><span class="line">      self = this;</span><br><span class="line">  var tmpFunc = function()&#123;&#125;;           // 构造函数原型链继承</span><br><span class="line">  var mainFunc = function()&#123;</span><br><span class="line">      var innerArgs = Array.prototype.slice.call(arguments);  //改变上下文之后的arguments</span><br><span class="line">      var finalArgs = args.concat(innerArgs);</span><br><span class="line">      return self.apply(this instanceof tmpFunc ? this : context || window,finalArgs);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  tmpFunc.prototype = this.prototype;</span><br><span class="line">  mainFunc.prototype = new tmpFunc();</span><br><span class="line">  return mainFunc;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><a href="/2019/05/04/改变上下文bind-apply-call/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/05/04/实现继承inherit/" class="post-title-link">实现继承inherit</a></h2><div class="post-info">May 4, 2019</div><div class="post-content"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function Parent(name, value) &#123;</span><br><span class="line">  console.log(&apos;parent&apos;, name, value);</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.value = value;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.foo = function () &#123;</span><br><span class="line">  console.log(`$&#123;this.name&#125;--$&#123;this.value&#125;`);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function inherit(parentClass, &#123; property &#125;) &#123;</span><br><span class="line">  function Child() &#123;</span><br><span class="line">    console.log(&apos;child&apos;, arguments);</span><br><span class="line">    parentClass.apply(this, [].slice.call(arguments));</span><br><span class="line">  &#125;</span><br><span class="line">  // Child.prototype = parentClass.prototype, 避免Parent prototype 更新传递</span><br><span class="line">  // Child.prototype = new parentClass() 避免实例化两次parentClass</span><br><span class="line">  function tmp()&#123;&#125;</span><br><span class="line">  tmp.prototype = parentClass.prototype;</span><br><span class="line">  Child.prototype = new tmp();</span><br><span class="line">  Child.prototype.constructor = Child;     // constructor 指向</span><br><span class="line">  for (key in property) &#123;</span><br><span class="line">    Child.prototype[key] = property[key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return Child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><a href="/2019/05/04/实现继承inherit/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/05/04/var-let-箭头函数与普通函数/" class="post-title-link">var let 箭头函数与普通函数</a></h2><div class="post-info">May 4, 2019</div><div class="post-content"><p>箭头函数对比普通函数：</p>
<ol>
<li>箭头函数没有this， 执行bind apply call 不能改变上下文</li>
<li>没有arguments</li>
<li>匿名函数，不能new 实例，没有prototype</li>
<li>不能作为generator函数，不能调用yeild</li>
</ol></div><a href="/2019/05/04/var-let-箭头函数与普通函数/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/05/04/instanceOf/" class="post-title-link">instanceOf</a></h2><div class="post-info">May 4, 2019</div><div class="post-content"><p>instanceOf 的判断是基于原型链，即比对右侧表达式是否在左侧表达式的原型链上。</p></div><a href="/2019/05/04/instanceOf/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/03/02/排序与树的遍历算法实现/" class="post-title-link">排序与树的遍历算法实现</a></h2><div class="post-info">Mar 2, 2019</div><div class="post-content"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 冒泡</span><br><span class="line">function sort1(arr)&#123;</span><br><span class="line">  for ( let i=0, len=arr.length; i&lt;len-1; i++ )&#123;</span><br><span class="line">    for ( let j=i+1; j&lt;=len-1; j++ )&#123;</span><br><span class="line">      if ( arr[i] &gt; arr[j] )&#123;</span><br><span class="line">        let tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><a href="/2019/03/02/排序与树的遍历算法实现/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/03/02/初次开发hybrid-H5的坑及方案/" class="post-title-link">初次开发hybrid H5的坑及方案</a></h2><div class="post-info">Mar 2, 2019</div><div class="post-content"><h4 id="hybrid-h5"><a href="#hybrid-h5" class="headerlink" title="hybrid h5"></a>hybrid h5</h4><p>hybrid 翻译为杂交， hyrid h5 是指将web前端页面嵌入到原生APP( iOS和Android )中的运行的方案。<br>相对于原生开发，web前端的开发发展时间更长、从业人员更多、生态更为繁荣，而且开发效率也更高。<br>但web并不能直接调用原生API，而且运行内存、调度也差与原生，流畅性就显得不足。<br>基于以上原因，协调开发资源，将一些展示性、交互不多的页面让web开发，嵌入原生Webview中运行，就可以大大提高APP开发效率，利用团队开发资源。</p></div><a href="/2019/03/02/初次开发hybrid-H5的坑及方案/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/12/02/小程序探索/" class="post-title-link">小程序探索</a></h2><div class="post-info">Dec 2, 2018</div><div class="post-content"><h3 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h3><ul>
<li>小程序需要申请账号，主体可以是企业，也可以是个人，里面有小程序的AppID，配置服务地址(比如localhost)</li>
<li>小程序开发工具，创建工程需要AppID</li>
<li>开发工具包含代码编辑器+调试器+客户端模拟器+版本管理器，基本做到了一站式开发</li>
<li>模拟器只有ios和 nexus，再加上原生组件，真机调试不可少</li>
</ul>
<h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><p>整个框架像个大杂烩，整体设计并不统一，包含了OO、函数式和面向过程。或许，是为了不同技术栈背景的开发人员都能找到一套适合的开发模式。</p>
<ul>
<li>样式层上来看，wxss像个css的子集，缺少了一些特性支持</li>
<li>模板wxml来看，Mustache语法，类似ng1.js的语法，数据与视图绑定，但数据流不是双向，不是响应式，而是类似React语法的setData，异步单项数据流</li>
<li>逻辑层js中，Page(Object)类似于Vue1的data设置，逻辑方法写法，同时也包含生命周期函数，可直接访问路由</li>
<li>wxs和template可直接在wxml中扩展，分别对应了script和模板引擎，可在多个地方引入调用，虽然提供了组件，但开发并不是组件化</li>
</ul>
<hr></div><a href="/2018/12/02/小程序探索/" class="read-more">...more</a></article></li></ul></main><footer><div class="paginator"><a href="/page/2/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">chendong</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>