<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> CDBlog</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="CDBlog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/05/04/改变上下文bind-apply-call/" class="post-title-link">改变上下文bind apply call</a></h2><div class="post-info">May 4, 2019</div><div class="post-content"><p>bind 返回一个函数， call apply 直接执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// bind</span><br><span class="line">if ( !Function.prototype.bind )&#123;</span><br><span class="line">Function.prototype.bind = function(context)&#123;</span><br><span class="line">  if ( typeof this !== &apos;function&apos; )&#123;</span><br><span class="line">    console.log(&apos;this is not function&apos;);</span><br><span class="line">    throw new Error(&apos;this is not function&apos;);</span><br><span class="line">    return ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var args = Array.prototype.slice.call(arguments, 1),</span><br><span class="line">      self = this;</span><br><span class="line">  var tmpFunc = function()&#123;&#125;;           // 构造函数原型链继承</span><br><span class="line">  var mainFunc = function()&#123;</span><br><span class="line">      var innerArgs = Array.prototype.slice.call(arguments);  //改变上下文之后的arguments</span><br><span class="line">      var finalArgs = args.concat(innerArgs);</span><br><span class="line">      return self.apply(this instanceof tmpFunc ? this : context || window,finalArgs);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  tmpFunc.prototype = this.prototype;</span><br><span class="line">  mainFunc.prototype = new tmpFunc();</span><br><span class="line">  return mainFunc;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><a href="/2019/05/04/改变上下文bind-apply-call/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/05/04/实现继承inherit/" class="post-title-link">实现继承inherit</a></h2><div class="post-info">May 4, 2019</div><div class="post-content"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function Parent(name, value) &#123;</span><br><span class="line">  console.log(&apos;parent&apos;, name, value);</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.value = value;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.foo = function () &#123;</span><br><span class="line">  console.log(`$&#123;this.name&#125;--$&#123;this.value&#125;`);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function inherit(parentClass, &#123; property &#125;) &#123;</span><br><span class="line">  function Child() &#123;</span><br><span class="line">    console.log(&apos;child&apos;, arguments);</span><br><span class="line">    parentClass.apply(this, [].slice.call(arguments));</span><br><span class="line">  &#125;</span><br><span class="line">  // Child.prototype = parentClass.prototype, 避免Parent prototype 更新传递</span><br><span class="line">  // Child.prototype = new parentClass() 避免实例化两次parentClass</span><br><span class="line">  function tmp()&#123;&#125;</span><br><span class="line">  tmp.prototype = parentClass.prototype;</span><br><span class="line">  Child.prototype = new tmp();</span><br><span class="line">  Child.prototype.constructor = Child;     // constructor 指向</span><br><span class="line">  for (key in property) &#123;</span><br><span class="line">    Child.prototype[key] = property[key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return Child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><a href="/2019/05/04/实现继承inherit/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/05/04/var-let-箭头函数与普通函数/" class="post-title-link">var let 箭头函数与普通函数</a></h2><div class="post-info">May 4, 2019</div><div class="post-content"><p>箭头函数对比普通函数：</p>
<ol>
<li>箭头函数没有this， 执行bind apply call 不能改变上下文</li>
<li>没有arguments</li>
<li>匿名函数，不能new 实例，没有prototype</li>
<li>不能作为generator函数，不能调用yeild</li>
</ol></div><a href="/2019/05/04/var-let-箭头函数与普通函数/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/05/04/instanceOf/" class="post-title-link">instanceOf</a></h2><div class="post-info">May 4, 2019</div><div class="post-content"><p>instanceOf 的判断是基于原型链，即比对右侧表达式是否在左侧表达式的原型链上。</p></div><a href="/2019/05/04/instanceOf/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/03/02/排序与树的遍历算法实现/" class="post-title-link">排序与树的遍历算法实现</a></h2><div class="post-info">Mar 2, 2019</div><div class="post-content"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 冒泡</span><br><span class="line">function sort1(arr)&#123;</span><br><span class="line">  for ( let i=0, len=arr.length; i&lt;len-1; i++ )&#123;</span><br><span class="line">    for ( let j=i+1; j&lt;=len-1; j++ )&#123;</span><br><span class="line">      if ( arr[i] &gt; arr[j] )&#123;</span><br><span class="line">        let tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><a href="/2019/03/02/排序与树的遍历算法实现/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/03/02/初次开发hybrid-H5的坑及方案/" class="post-title-link">初次开发hybrid H5的坑及方案</a></h2><div class="post-info">Mar 2, 2019</div><div class="post-content"><h4 id="hybrid-h5"><a href="#hybrid-h5" class="headerlink" title="hybrid h5"></a>hybrid h5</h4><p>hybrid 翻译为杂交， hyrid h5 是指将web前端页面嵌入到原生APP( iOS和Android )中的运行的方案。<br>相对于原生开发，web前端的开发发展时间更长、从业人员更多、生态更为繁荣，而且开发效率也更高。<br>但web并不能直接调用原生API，而且运行内存、调度也差与原生，流畅性就显得不足。<br>基于以上原因，协调开发资源，将一些展示性、交互不多的页面让web开发，嵌入原生Webview中运行，就可以大大提高APP开发效率，利用团队开发资源。</p></div><a href="/2019/03/02/初次开发hybrid-H5的坑及方案/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/12/02/小程序探索/" class="post-title-link">小程序探索</a></h2><div class="post-info">Dec 2, 2018</div><div class="post-content"><h3 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h3><ul>
<li>小程序需要申请账号，主体可以是企业，也可以是个人，里面有小程序的AppID，配置服务地址(比如localhost)</li>
<li>小程序开发工具，创建工程需要AppID</li>
<li>开发工具包含代码编辑器+调试器+客户端模拟器+版本管理器，基本做到了一站式开发</li>
<li>模拟器只有ios和 nexus，再加上原生组件，真机调试不可少</li>
</ul>
<h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><p>整个框架像个大杂烩，整体设计并不统一，包含了OO、函数式和面向过程。或许，是为了不同技术栈背景的开发人员都能找到一套适合的开发模式。</p>
<ul>
<li>样式层上来看，wxss像个css的子集，缺少了一些特性支持</li>
<li>模板wxml来看，Mustache语法，类似ng1.js的语法，数据与视图绑定，但数据流不是双向，不是响应式，而是类似React语法的setData，异步单项数据流</li>
<li>逻辑层js中，Page(Object)类似于Vue1的data设置，逻辑方法写法，同时也包含生命周期函数，可直接访问路由</li>
<li>wxs和template可直接在wxml中扩展，分别对应了script和模板引擎，可在多个地方引入调用，虽然提供了组件，但开发并不是组件化</li>
</ul>
<hr></div><a href="/2018/12/02/小程序探索/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/11/29/BizCharts调研/" class="post-title-link">BizCharts调研</a></h2><div class="post-info">Nov 29, 2018</div><div class="post-content"><h4 id="BizCharts"><a href="#BizCharts" class="headerlink" title="BizCharts"></a>BizCharts</h4><p>官网：<a href="https://bizcharts.net/" target="_blank" rel="noopener">https://bizcharts.net/</a></p>
<p>简单说下特性:</p>
<ul>
<li>基于 G2 封装的 React 图表库，具有 G2、React 的全部优点，可以让用户以组件的形式组合出无数种图表</li>
<li>集成了大量的统计工具，支持多种坐标系绘制，交互定制，动画定制以及图形定制等</li>
<li>性能稳定且具有强大的扩展能力和高度自定义能力</li>
</ul>
<hr></div><a href="/2018/11/29/BizCharts调研/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/09/16/关于ECharts-click事件的探索/" class="post-title-link">关于ECharts_click事件的探索</a></h2><div class="post-info">Sep 16, 2018</div><div class="post-content"><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>用echarts展示图表的时候，有时候需要点击当前图表，进行一些其他”effect side”操作,这个时候就需要得到当前这个点的横纵坐标的数据信息了。</p>
<hr>
<h4 id="探索方法"><a href="#探索方法" class="headerlink" title="探索方法"></a>探索方法</h4><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>查看官网API文档 <a href="http://www.echartsjs.com/api.html#echarts" target="_blank" rel="noopener">http://www.echartsjs.com/api.html#echarts</a>, 支持鼠标click事件，拿到基础的 line bar 图例上试验。<br>发现click触发条件是：</p>
<ol>
<li>line图需要点击到数据气泡点上，需要精准点击，数据多的时候，精准点击是困难的</li>
<li>bar图需要点击到柱状上，如果某几个数据bar很小，也存在精准点击困难的问题</li>
</ol>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>官网给出的API方法不尽如人意，去github上查找issue，发现有不少提出这问题。<br>解决方法：给出一个透明的bar坐标系重叠到图表上，透明bar的数据都是当前最大值，这样在图表对应的x轴都能实现触发点击，类似于tooltip那样方便。<br><a href="https://github.com/apache/incubator-echarts/issues/6106" target="_blank" rel="noopener">https://github.com/apache/incubator-echarts/issues/6106</a></p>
<p>但是，这个方法也有缺点：<br></div><a href="/2018/09/16/关于ECharts-click事件的探索/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/08/26/webpack分模块加载失败的问题/" class="post-title-link">记线上webpack分模块加载失败的问题</a></h2><div class="post-info">Aug 26, 2018</div><div class="post-content"><h3 id="问题一："><a href="#问题一：" class="headerlink" title="问题一："></a>问题一：</h3><p>用公司前端架构组给的tools工具时，在test环境下容易出现模块加载错误的问题。<br>观察发现，index.html， main.[hash].js 等资源文件缓存304， 各个路由页面引用的还是之前的hash资源，导致Jenkins新构建的资源没有被使用，而原来的资源已经被替换，找不到文件，所以出错。</p>
<p>将index.html 不缓存，每次 200 请求最新的，从而刷新各个资源文件。</p>
<h3 id="问题二："><a href="#问题二：" class="headerlink" title="问题二："></a>问题二：</h3><p>现象同样是加载失败。<br>区别1： 只有部分页面加载失败<br>区别2： 手动刷新，有时候页面又是好的，但另一个页面出问题。<br></div><a href="/2018/08/26/webpack分模块加载失败的问题/" class="read-more">...more</a></article></li></ul></main><footer><div class="paginator"><a href="/page/2/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">chendong</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>