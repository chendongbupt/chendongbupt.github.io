<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> canvas:path2D,离屏canvas · CDBlog</title><meta name="description" content="canvas:path2D,离屏canvas - chendong"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="CDBlog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">canvas:path2D,离屏canvas</h1><div class="post-info">Jan 14, 2018</div><div class="post-content"><h2 id="Path2D"><a href="#Path2D" class="headerlink" title="Path2D"></a>Path2D</h2><h4 id="Path2D-概念"><a href="#Path2D-概念" class="headerlink" title="Path2D 概念"></a>Path2D 概念</h4><p>Canvas 2D API 的接口 Path2D 用来声明路径，此路径稍后会被CanvasRenderingContext2D 对象使用。CanvasRenderingContext2D 接口的 路径方法 也存在于 Path2D 这个接口中，允许你在 canvas 中根据需要创建可以保留并重用的路径。<br><strong>当前IE safari 还不支持</strong></p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>一句话， <strong>缓存图形path</strong></p>
<h4 id="作用场景"><a href="#作用场景" class="headerlink" title="作用场景"></a>作用场景</h4><ul>
<li>假如随机生成的图形，常见的方法，保存图形参数</li>
<li><code>clearRect</code> 清空canvas后，需要回显刚才的图形</li>
<li><code>isPointInPath</code> 判断事件path区域</li>
</ul>
<a id="more"></a>
<p>常见使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">var tmpPathArr = [];</span><br><span class="line">for ( var i=0; i&lt;10; i++ )&#123;</span><br><span class="line">    var cx = Math.floor( Math.random()*300 ),</span><br><span class="line">        cy = Math.floor( Math.random()*300 ),</span><br><span class="line">        r = Math.floor( Math.random() * 255 ),</span><br><span class="line">        g = Math.floor( Math.random() * 255 ),</span><br><span class="line">        b = Math.floor( Math.random() * 255 ) ; </span><br><span class="line"></span><br><span class="line">    ctx.beginPath();  </span><br><span class="line">    ctx.fillStyle = &apos;rgb(&apos;+r+&apos;,&apos;+g+&apos;,&apos;+b+&apos;)&apos;;</span><br><span class="line">    ctx.arc(cx, cy, 30, 0, 2*Math.PI);</span><br><span class="line">    ctx.fill();</span><br><span class="line">    //保存图形的参数</span><br><span class="line">    tmpPathArr.push( &#123;cx:cx,cy:cy,rgb:ctx.fillStyle&#125; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//清空后回显</span><br><span class="line">ctx.clearRect(0,0, canvas.width, canvas.height);</span><br><span class="line">tmpPathArr.map(function(v)&#123;</span><br><span class="line">    ctx.beginPath();  </span><br><span class="line">    ctx.fillStyle = v.rgb;</span><br><span class="line">    ctx.arc(v.cx, v.cy, 30, 0, 2*Math.PI);</span><br><span class="line">    ctx.fill();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//isPointInPath</span><br><span class="line">canvas.onmousedown = function(ev)&#123;  </span><br><span class="line">    var e = ev||event;  </span><br><span class="line">    var x = e.clientX;  </span><br><span class="line">    var y = e.clientY;  </span><br><span class="line">    tmpPathArr.map(function(v)&#123;</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.arc(v.cx, v.cy, 30, 0, 2*Math.PI);</span><br><span class="line">        if ( ctx.isPointInPath(x,y) )&#123;  </span><br><span class="line">            // 判断区域</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>使用Path2D<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">var tmpPathArr = [];</span><br><span class="line">for ( var i=0; i&lt;10; i++ )&#123;</span><br><span class="line">    var cx = Math.floor( Math.random()*300 ),</span><br><span class="line">        cy = Math.floor( Math.random()*300 ),</span><br><span class="line">        r = Math.floor( Math.random() * 255 ),</span><br><span class="line">        g = Math.floor( Math.random() * 255 ),</span><br><span class="line">        b = Math.floor( Math.random() * 255 ) ; </span><br><span class="line"></span><br><span class="line">    ctx.beginPath();  </span><br><span class="line">    ctx.fillStyle = &apos;rgb(&apos;+r+&apos;,&apos;+g+&apos;,&apos;+b+&apos;)&apos;;</span><br><span class="line"></span><br><span class="line">    //利用path2直接保存图形，然后绘制图形</span><br><span class="line">    var path2D = new Path2D();        </span><br><span class="line">    path2D.arc(cx, cy, 30, 0, 2*Math.PI);</span><br><span class="line">    path2D.rgb = ctx.fillStyle;</span><br><span class="line">    ctx.fill( path2D );</span><br><span class="line">    //保存图形的参数</span><br><span class="line">    tmpPathArr.push( path2D );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//清空后回显</span><br><span class="line">ctx.clearRect(0,0, canvas.width, canvas.height);</span><br><span class="line">tmpPathArr.map(function(v)&#123;</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.fillStyle = v.rgb;</span><br><span class="line">    ctx.fill( v );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//isPointInPath</span><br><span class="line">canvas.onmousedown = function(ev)&#123;  </span><br><span class="line">    var e = ev||event;  </span><br><span class="line">    var x = e.clientX;  </span><br><span class="line">    var y = e.clientY;  </span><br><span class="line">    tmpPathArr.map(function(v)&#123;</span><br><span class="line">        if ( ctx.isPointInPath(v, x,y) )&#123;</span><br><span class="line">            //判断区域</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="Path2优点"><a href="#Path2优点" class="headerlink" title="Path2优点"></a>Path2优点</h4><ul>
<li>直接保存图形，不用关心图形参数，快速绘制</li>
<li>判断事件区域时，简单直接的使用 <code>ctx.isPointInPath(path2D,x,y)</code> ，不用绘制缓存的图形，取得上下文context后再判断</li>
<li>如果是多path的复杂图形，使用path2D优势将更明显，不需要保存图形复杂的绘制参数，方便开发和使用</li>
</ul>
<h2 id="离屏canvas"><a href="#离屏canvas" class="headerlink" title="离屏canvas"></a>离屏canvas</h2><h4 id="离屏canvas-1"><a href="#离屏canvas-1" class="headerlink" title="离屏canvas"></a>离屏canvas</h4><ul>
<li>创建的一个不显示的canvas，方便保存画布的静态场景</li>
<li>减少图形的绘制，优化性能</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//创建离屏canvas</span><br><span class="line">var  offCanvas = document.createElement(&quot;canvas&quot;);  </span><br><span class="line">offCanvas.width=400;  </span><br><span class="line">offCanvas.height=400;  </span><br><span class="line">var offContext = offCanvas.getContext(&quot;2d&quot;);  </span><br><span class="line"></span><br><span class="line">for ( var i=0; i&lt;10; i++ )&#123;</span><br><span class="line">    var cx = Math.floor( Math.random()*300 ),</span><br><span class="line">        cy = Math.floor( Math.random()*300 ),</span><br><span class="line">        r = Math.floor( Math.random() * 255 ),</span><br><span class="line">        g = Math.floor( Math.random() * 255 ),</span><br><span class="line">        b = Math.floor( Math.random() * 255 ) ; </span><br><span class="line">    //在离屏canvas上绘制场景，此时图形在离屏canvas上，并不显示</span><br><span class="line">    offContext.beginPath();  </span><br><span class="line">    offContext.fillStyle = &apos;rgb(&apos;+r+&apos;,&apos;+g+&apos;,&apos;+b+&apos;)&apos;;</span><br><span class="line">    offContext.arc(cx, cy, 30, 0, 2*Math.PI);</span><br><span class="line">    offContext.fill();</span><br><span class="line">&#125;</span><br><span class="line">//drawImage直接绘制整个离屏canvas的图形</span><br><span class="line">ctx.drawImage(offCanvas,0,0);</span><br></pre></td></tr></table></figure>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>静态的背景及不变的图形，每次重绘、回显时，可以直接绘制背景及图形，优化性能</li>
<li>重复或相似的图形，此时，可以将离屏canvas类比Sprite，保存各种图形的不同状态，利用<code>drawImage</code> 定位图形位置和区域大小，绘制要需要的部分图形</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2018/02/13/Angular1小结/" class="prev">上一篇</a><a href="/2018/01/01/svgvg-bezier/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">chendong</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>