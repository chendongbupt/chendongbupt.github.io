<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> CDBlog</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="CDBlog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/08/26/webpack分模块加载失败的问题/" class="post-title-link">记线上webpack分模块加载失败的问题</a></h2><div class="post-info">Aug 26, 2018</div><div class="post-content"><h3 id="问题一："><a href="#问题一：" class="headerlink" title="问题一："></a>问题一：</h3><p>用公司前端架构组给的tools工具时，在test环境下容易出现模块加载错误的问题。<br>观察发现，index.html， main.[hash].js 等资源文件缓存304， 各个路由页面引用的还是之前的hash资源，导致Jenkins新构建的资源没有被使用，而原来的资源已经被替换，找不到文件，所以出错。</p>
<p>将index.html 不缓存，每次 200 请求最新的，从而刷新各个资源文件。</p>
<h3 id="问题二："><a href="#问题二：" class="headerlink" title="问题二："></a>问题二：</h3><p>现象同样是加载失败。<br>区别1： 只有部分页面加载失败<br>区别2： 手动刷新，有时候页面又是好的，但另一个页面出问题。<br></div><a href="/2018/08/26/webpack分模块加载失败的问题/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/03/03/npm的一次问题/" class="post-title-link">npm的一次问题</a></h2><div class="post-info">Mar 3, 2018</div><div class="post-content"><p>环境： win<br>用<code>npm install npm -g</code> 升级npm后， npm失效，任意指令报错 <code>ERR: cannot find module &#39;xxx&#39;</code>， 但 node指令和cnpm都正常。<br>重新安装node，仍然有问题。</p>
<p>解决方法：<br>删除 <code>AppData/Roaming/</code> 文件夹下的 npm 和 npm-cache文件夹后解决问题，<br>npm npm-cache 是 全局npm包的安装，所以需要重新安装全局的npm包，如 cnpm, gulp, webpack等</p></div><a href="/2018/03/03/npm的一次问题/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/02/25/离线缓存/" class="post-title-link">离线缓存</a></h2><div class="post-info">Feb 25, 2018</div><div class="post-content"><p>当前有两种离线缓存方式，一种是H5离线缓存，基于manifest,一种是基于 Service Worker。</p>
<h3 id="manifest"><a href="#manifest" class="headerlink" title="manifest"></a>manifest</h3><p>其实manifest是一个简单的文本文件，它的扩展名是任意的，定义需要缓存的文件、资源，mime-type 为 text/cache-manifest 。<br>如： <code>&lt;html lang=&quot;en&quot; manifest=&quot;index.manifest&quot;&gt;</code></p>
<p>优点：</p>
<ul>
<li>离线浏览，无网情况下也能正常访问</li>
<li>更快的加载速度，缓存在本地访问速度自然更快</li>
<li>减轻服务请求压力，文件缓存后不需要再次请求，只需要请求需要更新的文件</li>
</ul>
<hr>
<p>manifest 文件可分为三个部分：</p>
<ul>
<li>CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存</li>
<li>NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存</li>
<li>FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）</li>
</ul>
<hr></div><a href="/2018/02/25/离线缓存/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/02/25/http缓存/" class="post-title-link">http缓存</a></h2><div class="post-info">Feb 25, 2018</div><div class="post-content"><h3 id="http的缓存策略"><a href="#http的缓存策略" class="headerlink" title="http的缓存策略"></a>http的缓存策略</h3><p>关键字段 Cache-Control: max-age, expires, ETag, Last-Modified</p>
<h4 id="优先级顺序"><a href="#优先级顺序" class="headerlink" title="优先级顺序"></a>优先级顺序</h4><ol>
<li><code>Cache-Control</code> : 强缓存，<code>no-cache</code>是不缓存， <code>max-age</code> 设置缓存生效时间，单位为秒(s)</li>
<li><code>Expires</code> : 缓存过期时间，单位是具体时间的 Date</li>
<li><code>ETag</code> : 资源内容的 hash 值， 如果资源没变化， <code>If-None-Match</code> 为false， 返回 304</li>
<li><code>Last-Modified</code> : 资源的最后修改日期，单位为秒(s)， <code>If-Modified-Since</code> 包含上一次的时间，如果一致，返回304</li>
</ol>
<h4 id="ETag-Last-Modefied"><a href="#ETag-Last-Modefied" class="headerlink" title="ETag Last-Modefied"></a>ETag Last-Modefied</h4><p>ETag是对Last-Modefied的功能补充，优先级更高。</p>
<ul>
<li>ETag是针对内容的 hash 变化，而 <code>Last-Modefied</code> 单位是秒， 对于 1s 内的多次改变无法感知。</li>
<li>周期性改变的资源，<code>Last-Modefied</code> 时间会改变，而内容不变的话，ETag 也不变，ETag对于缓存更有利。</li>
</ul></div><a href="/2018/02/25/http缓存/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/02/13/grunt-gulp/" class="post-title-link">grunt_gulp</a></h2><div class="post-info">Feb 13, 2018</div><div class="post-content"><p>###<br><code>grunt</code> 与 <code>gulp</code> 其实是很像的。</p>
<ul>
<li>loadNpmTasks(‘grunt-<em>‘) === requier(‘gulp-</em>‘)    //载入处理插件</li>
<li>registerTask === task   //创建任务</li>
<li>grunt [taskName]  ==== gulp [taskName]   //执行某个任务</li>
</ul>
<p>区别：</p>
<ul>
<li>对于要处理的文件较多较大时， gulp 基于流 速度会快不少</li>
<li>gulp简单的<code>.src-&gt;.pipe-&gt;.dest</code>,任务流程很清晰， 而grunt是基于配置，然后创建任务，配置与任务分离，如果配置较多时，可读性就不如gulp task了</li>
</ul>
<p>为什么gulp会比grunt更受欢迎? </p>
<ul>
<li>gulp 速度更快，这个可能是更多的情况，毕竟项目一般引入的外部资源都不少，如果一点改动就执行好几秒，体验是很差的，但可以解决，对dev开发环境进行配置，资源文件单独处理，生产环境再打包压缩。</li>
<li>gulp 主要API就5个 <code>.src</code> <code>.dest</code> <code>.pipe</code> <code>.task</code> <code>.watch</code>， 再配合官网的指南，上手难度低，而且任务可读性会更好</li>
</ul>
<p>两者一对比， gulp 的学习成本低、易上手的优势就更大了。</p></div><a href="/2018/02/13/grunt-gulp/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/02/13/Angular1小结/" class="post-title-link">Angular1小结</a></h2><div class="post-info">Feb 13, 2018</div><div class="post-content"><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>定义过滤器，返回一个filter function，在指令模板下可以进行一些筛选操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">angular.module(&apos;filterModule&apos;)</span><br><span class="line">    .filter(&apos;fileSize&apos;, function () &#123;</span><br><span class="line">      return function (value) &#123;</span><br><span class="line">        var bytes = parseInt(value, 10);</span><br><span class="line">        var byteLabel = bytes &gt; 1 ? &apos;Bytes&apos; : &apos;Byte&apos;;</span><br><span class="line">        var sizes = [byteLabel, &apos;KB&apos;, &apos;MB&apos;, &apos;GB&apos;, &apos;TB&apos;];</span><br><span class="line">        var i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));</span><br><span class="line">        return Math.round(bytes / Math.pow(1024, i), 2) + &apos; &apos; + sizes[i];</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="factory-service"><a href="#factory-service" class="headerlink" title="factory service"></a>factory service</h3><p>factory service 都可以提供 xhr 服务，功用类似。<br>区别在于factory是返回一个实例对象， 而service是将服务绑定在this上的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">angular.module(&apos;httpModule&apos;)</span><br><span class="line">    .factory(&apos;api&apos;, function($http, $q)&#123;</span><br><span class="line">        var api = &#123;&#125;;</span><br><span class="line">        api.func1 = function()&#123;&#125;</span><br><span class="line">        api.func2 = function()&#123;&#125;</span><br><span class="line"></span><br><span class="line">        return api;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">angular.module(&apos;httpModule&apos;)</span><br><span class="line">    .service(&apos;api&apos;, function($http, $q)&#123;</span><br><span class="line">        var self = this;</span><br><span class="line">        self.func1 = function()&#123;&#125;</span><br><span class="line">        self.func2 = function()&#123;&#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p>
<hr></div><a href="/2018/02/13/Angular1小结/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/01/14/canvas-path2D-离屏canvas/" class="post-title-link">canvas:path2D,离屏canvas</a></h2><div class="post-info">Jan 14, 2018</div><div class="post-content"><h2 id="Path2D"><a href="#Path2D" class="headerlink" title="Path2D"></a>Path2D</h2><h4 id="Path2D-概念"><a href="#Path2D-概念" class="headerlink" title="Path2D 概念"></a>Path2D 概念</h4><p>Canvas 2D API 的接口 Path2D 用来声明路径，此路径稍后会被CanvasRenderingContext2D 对象使用。CanvasRenderingContext2D 接口的 路径方法 也存在于 Path2D 这个接口中，允许你在 canvas 中根据需要创建可以保留并重用的路径。<br><strong>当前IE safari 还不支持</strong></p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>一句话， <strong>缓存图形path</strong></p>
<h4 id="作用场景"><a href="#作用场景" class="headerlink" title="作用场景"></a>作用场景</h4><ul>
<li>假如随机生成的图形，常见的方法，保存图形参数</li>
<li><code>clearRect</code> 清空canvas后，需要回显刚才的图形</li>
<li><code>isPointInPath</code> 判断事件path区域</li>
</ul></div><a href="/2018/01/14/canvas-path2D-离屏canvas/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/01/01/svgvg-bezier/" class="post-title-link">svgvg_bezier</a></h2><div class="post-info">Jan 1, 2018</div><div class="post-content"><h3 id="一种连接两个点的贝塞尔曲线"><a href="#一种连接两个点的贝塞尔曲线" class="headerlink" title="一种连接两个点的贝塞尔曲线"></a>一种连接两个点的贝塞尔曲线</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function bezier(startPoint, endPoint)&#123;</span><br><span class="line">    var sx = startPoint.x,</span><br><span class="line">        sy = startPoint.y,</span><br><span class="line">        ex = endPoint.x,</span><br><span class="line">        ey = endPoint.y,</span><br><span class="line">        length = Math.sqrt( Math.pow( (sx-ex), 2) + Math.pow( (sy-ey), 2 ) ) ;</span><br><span class="line"></span><br><span class="line">    //可以根据两点的倾斜方向做更加细致的取点，这里只列出其中一种方式</span><br><span class="line"></span><br><span class="line">    if ( Math.abs( sx - ex ) &lt; 5 )&#123;  //两个点的横坐标差值小于5，姑且认为是平行的，这里可以自行设置</span><br><span class="line">        return [startPoint, &#123;x:sx-length, y:sy&#125;, &#123;x:ex+length, y:ey&#125;, endPoint] ;</span><br><span class="line">    &#125;</span><br><span class="line">    else if ( Math.abs( sy - ey ) &lt; 5&gt; )&#123;  //纵坐标相同</span><br><span class="line">        return [startPoint, &#123;x:sx, y:sy-length&#125;, &#123;x:ex, y:ey+length&#125;, endPoint] ;        </span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;  //斜率的情况</span><br><span class="line">        var slope = (ey-sy) / (ex-sx),   //斜率</span><br><span class="line">            dx = Math.sqrt( Math.pow(length,2) / ( 1+ 1/(slope*slope) ) ),  //x坐标变化值</span><br><span class="line">            dy = Math.abs(-1/slope * dx)  ;</span><br><span class="line">        return [startPoint, &#123;x:sx-dx, y:sy-dy&#125;, &#123;x:ex+dx ,y:ey+dy&#125;, endPoint] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var pointArr = bezier(&#123;x:11, y:22&#125;, &#123;x:33, y:44&#125;);</span><br><span class="line">$(&apos;svg #path&apos;).attr(&apos;d&apos;, &apos;M&apos;+pointArr[0].x+&apos; &apos;+pointArr[0].y+&apos; C &apos;+pointArr[1].x+&apos; &apos;+pointArr[1].y+&apos;, &apos;+pointArr[2].x+&apos; &apos;+pointArr[2].y+&apos;, &apos;+pointArr[3].x+&apos; &apos;+pointArr[3].y);</span><br></pre></td></tr></table></figure></div><a href="/2018/01/01/svgvg-bezier/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/01/01/axios/" class="post-title-link">axios</a></h2><div class="post-info">Jan 1, 2018</div><div class="post-content"><p>### </p>
<p>简单来说，<code>axios</code>是<code>vue-resource</code>的替代品，基于Promise的HTTP请求库，适用于浏览器端和node.js。</p>
<hr></div><a href="/2018/01/01/axios/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/12/10/vuex-vue-router/" class="post-title-link">vuex+vue-router</a></h2><div class="post-info">Dec 10, 2017</div><div class="post-content"><h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h3><h4 id="routes"><a href="#routes" class="headerlink" title="routes"></a>routes</h4><ol>
<li>利用vue懒加载和webpack的代码分割，可以按需加载router组件，有效优化。<br><code>resolve =&gt; require([&#39;../components/main&#39;], resolve)</code></li>
<li>component 一个组件，对应 <strong>name=’default’</strong> 的 <code>router-view</code>，当然，未命名的router-view的默认name就是default， 所以有时候可以省略</li>
<li>components 是组件对象， key对应不同的视图名</li>
</ol></div><a href="/2017/12/10/vuex-vue-router/" class="read-more">...more</a></article></li></ul></main><footer><div class="paginator"><a href="/" class="prev">PREV</a><a href="/page/3/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">chendong</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>